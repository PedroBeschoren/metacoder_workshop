---
title: "metacoder workshop for the MICROP consortia"
output: html_document
knit: (function(input, ...) {
    )
    rmarkdown::render(
      input,
      output_dir = "../"
date: "2022-10-25"
author: "Pedro Beschoren da Costa, PhD"
institute: "Entomology Department - Wageningen University & Research"
editor_options: 
  chunk_output_type: console
---


```{r, setup, include=FALSE}
### you can safely ignore this chunk as a workshop participant ###

# this an an R markdown option for knitting documents, because working directory changes automatically in chunks. if you want details, check https://bookdown.org/yihui/rmarkdown-cookbook/working-directory.html
knitr::opts_knit$set(root.dir = '../')
```


# 1.0 - Install packages, load libraries

Here we source the bit of code that performs this operation. essentially, this one-line command runs an entire R script file. This can be handy when you load the same libraries in different steps of your analysis

```{r, warning = FALSE, message = FALSE}

source("./code/install_packages_load_libraries.R")

```

# 2.0 - Load and check data

Here we will load  data from 3 species in the Brassicacea family experiment: Arabidopsis thaliana, Brassica oleraceae and Isatis tinctoria. This data has been heavily filtered to reduce complexity and size. 

```{r}
# load object
load("./data/ps_rarefied.Rdata")

#check ps object
ps_rarefied # full ps object
otu_table(ps_rarefied)[1:5,1:5] # 5 first rows across 5 first columns
tax_table(ps_rarefied)[1:5,] # 5 first rows across all columns
ps_rarefied@sam_data [1:5,1:5]# metadata


``` 


# 3.0 - Create a single taxmap object for a single heat tree

For a simple start, let's create individual heat trees from an individual phyloseq object
```{r, message = FALSE}

# make a copy of you rarefied ps object
ps_rarefied_filt<-ps_rarefied

#remove unecessary taxonomic info ("ASV_id") by updating the tax table with a subset of the tax table
tax_table(ps_rarefied_filt)<-tax_table(ps_rarefied_filt)[,1:6]


# let's remove the "r__"ranks from the taxonomy, they can be useful but will pollute our plot
tax_table(ps_rarefied_filt)[, colnames(tax_table(ps_rarefied_filt))] <- gsub(pattern = "[a-z]__", # regular expression 
                                                                   x = tax_table(ps_rarefied_filt)[, colnames(tax_table(ps_rarefied_filt))], # "df"
                                                                   replacement = "") # replacement for pattern
# transform from phyloseq to taxmap object
taxmap_obj<-parse_phyloseq(ps_rarefied_filt)


```

## 3.1 - EXERCISE check taxmap object you just created

taxmap_obj is a object from the Taxmap class, but can be navigated as a nested list.
Explore taxmap_obj with "$"  and tab-completion. can you find the representative sequences in the data layer?
```{r, message = FALSE, results = "hide"}

# the taxmap object is a data container, just like phyloseq
taxmap_obj

# this object has much more than what you can see on one print, just like much other R output you generate. 
taxmap_obj$data$tax_data # taxa tables...
taxmap_obj$taxa # taxonomy names, ranks and codes


```

## 3.2 - Create the heat tree visualization

Now we can create a heat tree, with colors indicating the number of sequences in each taxa. 

The first tree is actually quite busy - depending on your goal, you might want to further filter the input ASVs to a smaller subset like all differentially abundant ASVs or features defined as core microbiome communities

```{r, message = FALSE, warning = FALSE}

# create a heat tree!
set.seed(1) # set a seed so the layout can be exactly the same every time
heat_tree(.input = taxmap_obj, # your taxmap object from the metacoder package
          node_size = n_obs, # n_obs is a function that calculates the number of OTUs per taxon 
          node_color = n_obs, # this function from metacoder is called with non-standard evaluation (no arguments)
          node_label = taxon_names, # labels for the taxons
          layout = "davidson-harel", # The primary layout algorithm
          initial_layout = "reingold-tilford", # The layout algorithm that initializes node locations
          output_file = "./results/heat_tree_test.pdf") # A PDF file you will export this plot to



```

Can you well which is the most diverse phylum?
which are the 3 most diverse families?

# QUESTION BREAK


## 3.3 - EXERCISE check arguments
check what's produced with the n_obs argument/function used in the tree above and also check the taxa names 

```{r, message = FALSE, results = "hide"}

#n_obs is a function that takesyour taxmap object as input, and return the number of sequences in each taxa
n_obs(taxmap_obj)

#in metacoder, ab, ac, ad, etc refer each to a different taxonomy
taxmap_obj$taxa

```

## 3.4 - Remove some taxa the heat tree visualization

It might be too dense/complex to look, so let's remove taxa names that can be  unfamiliar like  "phylum NB1-J"

```{r, message = FALSE, warning = FALSE}

# create a heat cleaner tree!
taxmap_obj %>%
  metacoder::filter_taxa(grepl(pattern = "^[a-zA-Z]+$", taxon_names)) %>% # remove "odd" taxa
  heat_tree(node_label = taxon_names,
            node_size = n_obs,
            node_color = n_obs,
            layout = "davidson-harel",
            initial_layout = "reingold-tilford",
            output_file = "./results/heat_tree_test_cleaner.pdf")



```




## 3.5 - Modify the tree with available options

There are many options to customize these trees, we will only explore a few of them

### 3.5.1 -  Truncate at order level

This tree stops at Order level
```{r, message = FALSE, warning = FALSE}

# create a heat cleaner tree!
taxmap_obj %>%
  metacoder::filter_taxa(grepl(pattern = "^[a-zA-Z]+$", taxon_names)) %>% # remove "odd" taxa
  metacoder::filter_taxa(taxon_ranks == "Order", supertaxa = TRUE) %>% # subset to the Order rank
  heat_tree(node_label = taxon_names,
            node_size = n_obs,
            node_color = n_obs,
            layout = "davidson-harel",
            initial_layout = "reingold-tilford",
            output_file = "./results/heat_tree_order.pdf")

```

### 3.5.2 - make individual roots for specific taxonomic groups

This tree has a separated root at different taxonomic levels, and custom colors
```{r, message = FALSE, warning = FALSE}

# create a heat cleaner tree!
taxmap_obj %>%
  metacoder::filter_taxa(grepl(pattern = "^[a-zA-Z]+$", taxon_names)) %>% # remove "odd" taxa
  metacoder::filter_taxa(taxon_names %in% c("Rhizobiales", "Actinobacteria", "Xanthomonadaceae"),
              subtaxa = TRUE, 
              supertaxa = FALSE) %>% 
  heat_tree(node_label = taxon_names,
            node_size = n_obs,
            node_color = n_obs,
            node_color_range = c("blue", "yellow", "pink", "red"),
            layout = "davidson-harel",
            initial_layout = "reingold-tilford",
            output_file = "./results/heat_tree_sep_roots.pdf")



```




## 3.6 - Compare 2 groups of samples
lets now compare ASV abundances between two groups of samples, such as plant species in brassicaceae lineage I and II (Sp_Lineage_Walden). 

### 3.6.1 -  calculate taxon abundance
"tax_abund" is added as a data layer of the taxmap object. it defines the number of sequences on every single taxon  - all phyla, all classes, orders... this is different from counts of every single ASV! this data layer is needed on the next step.


```{r, message = FALSE}
#get abundance per taxon
taxmap_obj$data$tax_abund<-calc_taxon_abund(obj = taxmap_obj, # the taxmap object
                                            data = "otu_table", # layer of data table to use
                                            cols = taxmap_obj$data$sample_data$sample_id) #sample names

#check the new data layer you created. note that "ab" refers to "k__Bacteria",  and "aac" to "p__Proteobacteria".  
taxmap_obj$data$tax_abund

#quickly compare those values to the OTU table to see the differnce:
taxmap_obj$data$otu_table

```

### 3.6.2 -  Calculate taxon prevalence/occumpancy

here we define taxa "occurrence" by determining in how many samples of each group they appear
```{r, message = FALSE}

#get occurrence of per lineage
taxmap_obj$data$tax_occ_2lineages <- calc_n_samples(obj = taxmap_obj, 
                                                    data = "tax_abund", 
                                                    cols = taxmap_obj$data$sample_data$sample_id,
                                                    groups = taxmap_obj$data$sample_data$Sp_Lineage_Walden) # What category each sample is



#check the object. it shows how many times a taxon is represented in lineage I or II
taxmap_obj$data$tax_occ_2lineages

```

### 3.6.3 -  Calculate log fold changes between two groups
Here we see log fold changes

```{r, message = FALSE}
# this will calculate log2 median ratios and p values for a wilcoxcon test within taxas in this lineage
taxmap_obj$data$diff_table_2lineages <- compare_groups(obj = taxmap_obj,
                                                      data = "tax_abund",
                                                      cols = taxmap_obj$data$sample_data$sample_id, 
                                                      groups = taxmap_obj$data$sample_data$Sp_Lineage_Walden) 

#check the object.
taxmap_obj$data$diff_table_2lineages

```

### 3.6.4 - Plot heat tree showing log-fold differences
tan indicates lineage II, cyan indicates lineage I

```{r, message = FALSE, warning = FALSE}

taxmap_obj %>%
  metacoder::filter_taxa(grepl(pattern = "^[a-zA-Z]+$", taxon_names)) %>% # remove "odd" taxa
  heat_tree(node_label = taxon_names,
            node_size = n_obs,
            node_color = log2_median_ratio,
            node_color_interval = c(-3, 3), # The range of `log2_median_ratio` to display
            node_color_range = c("cyan", "gray", "tan"), # The color palette used
            layout = "davidson-harel",
            node_color_axis_label = "Log2 ratio, cyan for Lineage I",
            initial_layout = "reingold-tilford",
            output_file = "./results/heat_tree_diff_lineages.pdf")




```



### 3.6.5 - Supress non-significant differences and plot log changes again 
This plot indicates log fold changes, but includes p values > 0.05. let's run any non-significant differences into a median log ratio of zero, shading them as grey in the plot

```{r, message = FALSE, warning = FALSE}

# set differential log ratio to 0 based on p values below 0.05
taxmap_obj$data$diff_table_2lineages$log2_median_ratio[taxmap_obj$data$diff_table_2lineages$wilcox_p_value > 0.05] <- 0

# plot the heatmap
taxmap_obj %>%
  metacoder::filter_taxa(grepl(pattern = "^[a-zA-Z]+$", taxon_names)) %>% # remove "odd" taxa
  heat_tree(node_label = taxon_names,
            node_size = n_obs,
            node_color = log2_median_ratio,
            node_color_interval = c(-3, 3), # The range of `log2_median_ratio` to display
            node_color_range = c("cyan", "gray", "tan"), # The color palette used
            layout = "davidson-harel",
            node_color_axis_label = "Log2 ratio, cyan for Lineage I",
            initial_layout = "reingold-tilford",
            output_file = "./results/heat_tree_diff_lineages_pcut.pdf")






```

From this figure, we could see a larger presence of low-diversity phyla in lineage I (cyan). lineage II has a clear increase in Sphingomonadaceae. both lineages seem to be colonized by several, but different, bacteroidia and actinobacteria. Family Comamonadaceae and Chitinophagaceae seem to be the most diverse

# QUESTION BREAK

## 3.7 - Compare 3 or more groups of samples

If you have more than 2 groups, like we have 3 different stresses, you can plot a matrix of heat trees with a dedicated function from the same package. Before we do that, let's first calculate taxon abundance, prevalence, and log-fold changes like we did in chunks 3.5.1 to 3.5.3

### 3.7.1 - Calculate abudance, prevalence and log-fold in  3 treatment groups

```{r, message = FALSE, warning = FALSE}

#abundance per taxon was already calculated in chunk 3.5.1, now we just overwrite
taxmap_obj$data$tax_abund<-calc_taxon_abund(obj = taxmap_obj, 
                                            data = "otu_table", 
                                            cols = taxmap_obj$data$sample_data$sample_id) 

#get occurrence of ASVs per treatment
taxmap_obj$data$tax_occ_3treatments <- calc_n_samples(obj = taxmap_obj, 
                                                      data = "tax_abund", 
                                                      cols = taxmap_obj$data$sample_data$sample_id,
                                                      groups = taxmap_obj$data$sample_data$Stress) # now refer to Stress, that has 3 groups

# calculate log2 median ratios and p values for a wilcoxcon test within taxas in this stress treatment groups
taxmap_obj$data$diff_table_3treatments <- compare_groups(obj = taxmap_obj,
                                                        data = "tax_abund",
                                                        cols = taxmap_obj$data$sample_data$sample_id, 
                                                        groups = taxmap_obj$data$sample_data$Stress) 

# set differential log ratio to 0 based on adjusted p values
taxmap_obj$data$diff_table_3treatments$log2_median_ratio[taxmap_obj$data$diff_table_3treatments$wilcox_p_value > 0.05] <- 0

# because of potential ambiguity in non-standard evaluation, we should change this column name. this is only needed because of the column taxmap_obj$data$diff_table_2lineages$log2_median_ratio we created in chunk 3.5.3 
names(taxmap_obj$data$diff_table_3treatments)[4]<-"log2_median_ratio_stress"



```


### 3.7.2 - Plot a matrix of heat trees
Now that we have log-fold differences in pairwise treatment comparisons, let's compare them in a matrix of heat trees

```{r, message = FALSE, warning = FALSE}

#plot matrix tree
set.seed(1)
heat_tree_matrix(taxmap_obj,
                 data = "diff_table_3treatments", # this is the table with the data you want to plot
                 node_size = n_obs, # n_obs is a function that calculates, in this case, the number of OTUs per taxon
                 node_label = taxon_names,
                 node_color = log2_median_ratio_stress, # A column from `taxmap_obj$data$diff_table_3treatments`
                 node_color_range = diverging_palette(), # The built-in palette for diverging data
                 node_color_trans = "linear", # The default is scaled by circle area
                 node_color_interval = c(-3, 3), # The range of `log2_median_ratio` to display
                 edge_color_interval = c(-3, 3), # The range of `log2_median_ratio` to display
                 node_size_axis_label = "Number of OTUs",
                 node_color_axis_label = "Log2 ratio median proportions",
                 layout = "davidson-harel", # The primary layout algorithm
                 initial_layout = "reingold-tilford", # The layout algorithm that initializes node locations
                 output_file = "./results/matrix_heat_tree_Stress.pdf") # Saves the plot as a pdf file

```

### 3.7.3 - EXERCISE change grouping variable 
by changing the code above, Make a matrix of heat trees that plots the differences between the 3 plant species we are using. The metadata for that is present in the metadata column "sp_full_name". Which alphaproteobacteria are more common in Brassica oleracea than Isatis tinctoria?

```{r, include=FALSE}
# code your exercise here!




```


# QUESTION BREAK


## 3.8 - Create a matrix of heat trees from a phyloseq object with a single function

These trees are interesting, but as you start exploring real data and multiple options you will need a more efficiency way of running all this code. For this, we create a custom function that handles all of it at once, 

### 3.8.1 - Define a custom function

This custom function will: 

1 - truncate the taxonomy table to genus level,  
2 - remove the g__ and f__ etc from taxonomy table
3 - parse the phyloseq object into a taxmap object, 
4 - calculate taxa occurrence, abundance and log-fold differences between groups of samples that you define
5 - plot a heat tree

It's arguments are
1 - ps_object = a phyloseq object
2 - sample_group = a (quoted) column from the sample metadata that you want to compare

The function will count the number of different groups in your metadata column to decide if it will plot a heat tree (2 treatments/groups) or matrix of heat trees (3+ treatments). the function should fail if your metadata only has 1 sample group!


```{r, message = FALSE, warning = FALSE}

phyloseq_to_heat_tree_matrix<-function(ps_object, sample_group){
  
  # this function output is a heat trees comparing metadata. the input is based on a phyloseq object
  
  # ps object =  a phyloseq object, containing sample metadata, otu table, and taxonomy table
  # sample_group = the name of a column in your emtadata that you want to compare in the heat tree. it has to be quoted.
  
  # this function will create a matrix of heat trees if your metadata has more than 2 groups. it should fail if it has only 1 group
  

#remove unecessary taxonomic info (dada2id, "s__" and "ASV_id) by updating the tax table with a subset of the tax table
tax_table(ps_object)<-tax_table(ps_object)[,1:6]


# let's remove the "r__"ranks from the taxonomy, they can be useful but will pollute our plot
tax_table(ps_object)[, colnames(tax_table(ps_object))] <- gsub(pattern = "[a-z]__", # regular expression pattern to search for
                                                                   x = tax_table(ps_object)[, colnames(tax_table(ps_object))], # "df"
                                                                   replacement = "") # replacement for pattern
# transform from phyloseq to taxmap object
taxmap_obj<-parse_phyloseq(ps_object)

#get abundance per taxon
taxmap_obj$data$tax_abund<-calc_taxon_abund(obj = taxmap_obj, 
                                      data = "otu_table",
                                      cols = taxmap_obj$data$sample_data$sample_id) 

#get occurrence of ASVs per treatment
# the sample groups needs some wrangling to fit within the soft code of the function
taxmap_obj$data$tax_occ<- calc_n_samples(obj = taxmap_obj, 
                                                      data = "tax_abund", 
                                                      cols = taxmap_obj$data$sample_data$sample_id,
                                                      groups = taxmap_obj$data$sample_data[colnames(taxmap_obj$data$sample_data)==sample_group][[1]]) 

# calculate log2 median ratios and p values for a wilcoxcon test within taxas in this stress treatment groups
# the sample groups needs some wrangling to fit within the soft code of the function
taxmap_obj$data$diff_table <- compare_groups(obj = taxmap_obj,
                                                        data = "tax_abund",
                                                        cols = taxmap_obj$data$sample_data$sample_id, 
                                                        groups = taxmap_obj$data$sample_data[colnames(taxmap_obj$data$sample_data)==sample_group][[1]]) 

# set differential log ratio to 0 based on adjusted p values
taxmap_obj$data$diff_table$log2_median_ratio[taxmap_obj$data$diff_table$wilcox_p_value > 0.05] <- 0

# define number of compared factors
factors_compared<-taxmap_obj$data$sample_data[colnames(taxmap_obj$data$sample_data)==sample_group][[1]] 

# draw the plot based on an if else statement: if there are 2 groups, plot a a heat tree comparing abundances between both groups, else plot a matrix of ehat trees. this function will fail if you only have 1 sample group! 

if (length(unique(factors_compared)) == 2) {

set.seed(1)
 output<- taxmap_obj %>%
heat_tree(
            node_label = taxon_names,
      #      data = "diff_table", 
            node_size = n_obs,
            node_color = log2_median_ratio,
            node_color_interval = c(-3, 3), # The range of `log2_median_ratio` to display
            node_color_range = c("cyan", "gray", "tan"), # The color palette used
            layout = "davidson-harel",
            initial_layout = "reingold-tilford")

 } else {

set.seed(1)
output<-heat_tree_matrix(taxmap_obj,
                         data = "diff_table", # this is the table with the data you want to plot
                         node_size = n_obs, # n_obs is a function that calculates, in this case, the number of OTUs per taxon
                         node_label = taxon_names,
                         node_color = log2_median_ratio, # A column from `taxmap_obj$data$diff_table_3treatments`
                         node_color_range = diverging_palette(), # The built-in palette for diverging data
                         node_color_interval = c(-3, 3), # The range of `log2_median_ratio` to display
                         edge_color_interval = c(-3, 3), # The range of `log2_median_ratio` to display
                         node_size_axis_label = "Number of OTUs",
                         node_color_axis_label = "Log2 ratio median proportions",
                         layout = "davidson-harel", # The primary layout algorithm
                         initial_layout = "reingold-tilford") # The layout algorithm that initializes node locations

   
   
 }


# clearly define the output object you will get from the function
return(output)   


}

```

### 3.8.2 - Creating heat trees from a custom function

Now that we defined a new function that takes a phyloseq object as a data input and a column of the metadata as an argument, we can more easily produce heat trees across the variables.



```{r, message = FALSE, warning = FALSE}
# run custom function
heat_tree_stress<-phyloseq_to_heat_tree_matrix(ps_object = ps_rarefied, sample_group = "Stress")
heat_tree_lineage<-phyloseq_to_heat_tree_matrix(ps_object = ps_rarefied, sample_group = "Sp_Lineage_Walden")

# check stress tree
heat_tree_stress

# check lineage tree
heat_tree_lineage



```



### 3.8.3 - EXERCISE make more heat trees!

Now that you know the basics, let's manipulate some of these visualizations

#### 3.8.3.1 - EXERCISE use custom function

Now produce new heat tree, based on metadata like "Sp_full_name", "greenhouse_compartment" or "Speed"!

```{r, include=FALSE}
# use this space to run the  phyloseq_to_heat_tree_matrix() function defined above, based on the object ps_rarefied





```

#### 3.8.3.2 - EXERCISE see Burkholderiales and Rhizobiales at ASV level 

Our trees so far stopped at genus level, because ploting 2000 ASVs would overcrowd the plot. *Show the "Sp_full_name" effect at ASV level, but only on Burkholderiales and Rhizobiales. What do you have to change, and where?* You can copy-paste and adjust the code we saw above, or make a new version of the custom function

```{r, include=FALSE}
# code your exercise here!


```

#### 3.8.3.3 - EXERCISE remove kingdom from taxonomy table

Our trees so far have k__Bacteria as a shared root. *What will happen if you remove that taxonomic information? to make this change, What do you have to alter?* You can copy-paste and adjust the code we saw above,  or make a new version of the custom function

```{r, include=FALSE}
# code your exercise ehre!



```





# 4.0 - Create a list of taxmap objects for a single heat tree
Now that we have a function that takes a single phyloseq object as input, let's run it across all the species in the dataset


## 4.1 - Create a list of phyloseq objects
First, let's split the phyloseq object into a list of phyloseq objects according the species

note that the phyloseq input is based on the original phyloseq object, that still contains the ranks as p__Proteobacteria, o__Rhizobiales, etc


```{r, message = FALSE, warning = FALSE}
# turn a ps object into a list f ps objects
ps_l<- metagMisc::phyloseq_sep_variable(ps_rarefied, variable = "Sp_abb_name")


```


## 4.2 - Check list of phyloseq objects
Let's check the list we just created. there are different ways we can do this


```{r, message = FALSE, warning = FALSE}
# check object, which is a list of phyloseq objects (ps_l)
ps_l

# access the Arabidosps phyloseq object
ps_l$At

# access the taxonomy table of the  Arabidosps phyloseq object
ps_l$At@tax_table[1:5,]

# check metadata of the second list object
sample_data(object = ps_l[[2]])[1:5,1:5]

```


## 4.4 - Run custom function on list of phyloseq objects
lapply (list apply) will apply a function over a list. as we have a list of phyloseq objects now, it will be easy to produce several matrices of heat trees. when working on lists of 33 species we learned that 33 plots are hardly helpful. still, the code and the concept (make a custom function that uses a phyloseq object as input, then run over a list with lapply) can be very useful on your own analysis

```{r, message = FALSE, warning = FALSE}

# are you new to lapply? see here how it works. you first provide a list ("ps_l"), and then a function ("ntaxa") you will run independently on each element x of your list(ps_l$At, ps_l$Bo_M, ps_l$It). here we simply count the number of taxa of each of the 3 phyloseq objects in the list
lapply(ps_l, function(x)  
  ntaxa(x))


# run the custom function over a list of phyloseq objects... it can take a moment
heat_tree_stress_l<-lapply(ps_l, function(x)  
  phyloseq_to_heat_tree_matrix (ps_object = x, sample_group = "Stress"))


```


# QUESTION BREAK

# 5.0 - Adding external data to the heat trees
What if we want to visualize other types of taxa-associated data, like p values from deseq2, importance in random forest predictions, distances in an ordination, or degree in a network? You can do that, as long as the vector of values you use as node_size or node_colour have the same length as the number of taxon names you are plotting. You can for example add another data layer to the taxmap object, or provide data from an independent df as the argument of node_size or node_colour.



## 5.1 - Check some input arguments of a heat tree
To explore this, lets first check some of the taxmap object structure, then create some random data and add it to the heat tree


```{r, message = FALSE, warning = FALSE, results='hide'}

# let's review one of the more basic trees.
taxmap_obj %>%
  heat_tree(node_label = taxon_names,
            node_size = n_obs,
            node_color = n_obs,
            layout = "davidson-harel",
            initial_layout = "reingold-tilford")
```
```{r, message = FALSE, warning = FALSE}
#let's review what is actually used as input for node size and color
n_obs(taxmap_obj)

# ab, es, ff etc all refer to specific nodes int he tree taxonomic groups. the number referts to how many sequences belong to that taxonomy (all 1000 sequences, are part of Bacteria "ab", 574 are Proteobacteria "ac")
taxmap_obj$taxa[1:10]

```



So if you have a vector from the same length of n_obs(taxmap_obj) with data from other analysis, you can visualize other outputs in a heat tree! lets prepare a df that will add new, random data



## 5.2 - Extract taxon information from the taxmap object
let's extract the taxon ids from the taxmap object 

```{r, message = FALSE, warning = FALSE}
#extract the names of the taxonomies in the heat tree, accoding the ab ac etc order
taxon_id_metacoder<-lapply(taxmap_obj$taxa, function (x)
                                                    x$get_name())%>%
                                                    map(1)

# now turn that list into a df
taxon_id_metacoder<-do.call(rbind.data.frame, map(taxon_id_metacoder,1))

# and change column name
colnames(taxon_id_metacoder)<-"taxa_id"

#check output
head(taxon_id_metacoder)

```

## 5.3 - Check some input arguments of a heat tree
then create new (random) data, and add it to the taxon information you extracted
```{r, message = FALSE, warning = FALSE}

#make up some random data called new_data1
set.seed(1)
new_data1<-c(runif(n=100, min=1, max=10),
            runif(n=200, min=5, max=15),
            runif(n=100, min=10, max=20),
            runif(n=57, min=20, max=25))

#make up some random data called new_data2
set.seed(1)
new_data2<-c(runif(n=57, min=1000, max=2000),
             runif(n=200, min=600, max=1000),
             runif(n=200, min=200, max=500))


# add new (random example) data into the df
taxon_id_metacoder$new_analysis_output1<-new_data1
taxon_id_metacoder$new_analysis_output2<-new_data2

#this is the df we created using data external from metacoder
taxon_id_metacoder[1:10,]
```


## 5.4 - Make a new heat tree with the new random data
the size of the node will relate to the first column of the new dataframe. the color of the node will related the the second column of the new dataframe

in a real case, you would have your valuable data, taxon by taxon, in a dataframe with similar structure

```{r, message = FALSE, warning = FALSE}


# add the new data into the heat tree!
taxmap_obj %>%
  heat_tree(node_label = taxon_names,
            node_size = taxon_id_metacoder$new_analysis_output1,
            node_color = taxon_id_metacoder$new_analysis_output2,
            node_size_axis_label = "Size: new data 2",
            node_color_axis_label = "Color: new data 1",
            layout = "davidson-harel",
            initial_layout = "reingold-tilford")



```


Of course, there are countless ways you can integrate different pieces of data together - such as by matching the taxonomies ab, ac, ad etc; the names of the taxa like "f__Burkholderiales" etc. Note that you won't find sample code for this (adding external data)  in the metacoder package documentation.




# QUESTION BREAK







# 6.0 - adding results of a fisher tests to a heat tree

In the MeJA applications pilot were we tested different MeJA concentrations, we run different analysis that highlight taxa as "important": predictors for stress in random forest, keystone nodes in networks, and differentially abundant ASVs in treatment-control comparisons. to select which of the taxonomies of these "important" taxa to focus on, we performed a fisher test to check if the proportions of a taxonomy are similar between the important ASVs and the ASVs that were not defined as important.

The paper with further details should be submitted for publication this by Nov/Dez 2022 ~ you can cite that paper in the near future to use this code

## 6.1 - Load important taxa names, create new ps object

These ASVs listed in "imp_asv_list.Rdata" were highlighted as differential abundant due to stress treatments OR important in random forest predictions for stress treatments OR network keystone/connector/hub of the species in a more complete dataset (with 70k ASVs). I call these the "important"ASVs.

After we load these ASVs names, we create a list of new ps objects by running phyloseq::prune_taxa (a function that selects taxa in a ps object according a character vector) with base::mapply  (a function that runs a function on two lists simultaneously)

```{r}
# load a list of ASV names. 
load( file="./data/imp_asv_list.Rdata")

imp_asv_list # as you see, this is just a list of taxa

# filter your list of phyloliseq objects to only contain the ASVs defined as "importat"
imp_ASV_ps_l<-mapply (function (list_1,list_2) #mapply will let you manipulate 2 or more lists at once
            prune_taxa(taxa = list_1, x = list_2), #here, x as the name of an argument of prune_taxa, and refers to a phyloseq object
          list_1 = imp_asv_list, # here you define what R object is list_1
          list_2 = ps_l, # here you define what R object is list_2
          SIMPLIFY = FALSE)

# this ps object only has "important" ASVs
imp_ASV_ps_l


```

*NOTE* that the input is just a list of ASV names. you could use this function to summarize any other analysis method that tags several ASVs as relevant in your analysis

## 6.2 - define the funciton that calculates fisher tests and heat trees
If we have the time, we explore details for these functions. their description and comments should be fairly sufficiency

the fisher_all_taxa_groups function requires as input: 
1) a phyloseq object that contains your "important" taxa
2) a phyloseq objects that contains all your taxa

the fisher_to_heatTree function requires as input
1) the output of the fisher_all_taxa_groups function
2) a phyloseq object that contains your "important" taxa

```{r message=FALSE, warning=FALSE, include=FALSE, results='hide'}


#define function that calculates proportion tests between 2 phyloseq objects
fisher_all_taxa_groups<-function(ps_important_taxa, ps_all_taxa){

#**********************************************#
############# fisher_all_taxa_groups ################
#**********************************************#

# this function takes 2 phyloseq objects as 2 arguments:
# ps_important_taxa =  a subset of imporntant taxa, such as ASVs tagged as important by differential abundance, random forest, and netowrk analysis
# ps_all_taxa = the full phyloseq objects from where you obtained the imporntat subset (and likely your input for differential abundance, random forest, and netowork analysis)

# Then it runs a fisher test, comparing the proportions of every taxonomic level accuting more than twice in both datasets
# it's just a test to compare proportions - is 6 out of 17 a similar proportion to 193 out of 2243?

  
  
# first, get the taxonomic groups of the taxa defined as important
  
  #this will get us a list of (taxa_level) that appears in the important subset more than once
  imp_phylum_l<-as.character(tax_table(ps_important_taxa)[,"Phylum"]) # gets a char vector  of "families" shown as relevant
  imp_phylum_l<-imp_phylum_l[imp_phylum_l != "p__uncultured"] # removes any taxonomy set as "uncultured"
  imp_phylum_l<-names(which(table(imp_phylum_l)>2))%>% # get names of taxa that occur ate least 1 time NOTE: CHANGED FROM >2
    na.omit()%>% #remove NA from classifications
    unique()%>%  #dereplicates repetitive values (avoids "f__Chitinophagaceae" "f__Chitinophagaceae" "f__Oxalobacteraceae")
    as.list(c()) # save the dereplicated values as a list
  
  # now, perfom the same as above for every taxa level... it's hard-coded, but it works well enough. Pedro tried automating this and gave up after a few hours
  imp_class_l<-as.character(tax_table(ps_important_taxa)[,"Class"]) 
  imp_class_l<-imp_class_l[imp_class_l != "c__uncultured"] 
  imp_class_l<-names(which(table(imp_class_l)>2))%>% 
    na.omit()%>% 
    unique()%>%  
    as.list(c()) 
  
  imp_order_l<-as.character(tax_table(ps_important_taxa)[,"Order"])
  imp_order_l<-imp_order_l[imp_order_l != "o__uncultured"]
  imp_order_l<-names(which(table(imp_order_l)>2))%>%
    na.omit()%>% 
    unique()%>%
    as.list(c()) 
  
  imp_fam_l<-as.character(tax_table(ps_important_taxa)[,"Family"])
  imp_fam_l<-imp_fam_l[imp_fam_l != "f__uncultured"]
  imp_fam_l<-names(which(table(imp_fam_l)>2))%>%
    na.omit()%>% 
    unique()%>% 
    as.list(c()) 
  
  imp_genus_l<-as.character(tax_table(ps_important_taxa)[,"Genus"])
  imp_genus_l<-imp_genus_l[imp_genus_l != "g__uncultured"]
  imp_genus_l<-names(which(table(imp_genus_l)>2))%>%
    na.omit()%>% 
    unique()%>% 
    as.list(c()) 
  
  
  
  
  
  
  
  
  
  # second, get the number of taxa occuring in each taxonomic group, within the imporntat taxa subset
  # note: using phyloseq::subset_taxa with a for loop will cause issues as your taxa is intepreted as "i"! to avoid this, use phyloseq::prune_taxa instead
  
  
  
  #make one empty lists to store results
  target_in_important_n<-list()
  
  # obtain the number of reads of the target taxa in the important subset
  for(i in imp_phylum_l) { #for every Phylum "i" with representatives defined as important....
    target_in_important_n[i]<-phyloseq::ntaxa(prune_taxa(taxa = tax_table(ps_important_taxa)[,"Phylum"] %in% i, # get only the taxa that belong to that particular phylum "i", then define the number of taxa in there, then save it in the empty list we just made to store the results
                                                         x = ps_important_taxa))
  }
  
  # now, perfom the same as above for every taxa level... it's hard-coded, but it works well enough. Pedro tried automating this and gave up after a few hours
  for(i in imp_class_l) {
    target_in_important_n[i]<-phyloseq::ntaxa(prune_taxa(taxa = tax_table(ps_important_taxa)[,"Class"] %in% i,
                                                         x = ps_important_taxa))
  }
  
  for(i in imp_order_l) {
    target_in_important_n[i]<-phyloseq::ntaxa(prune_taxa(taxa = tax_table(ps_important_taxa)[,"Order"] %in% i,
                                                         x = ps_important_taxa))
  }
  
  
  for(i in imp_fam_l) {
    target_in_important_n[i]<-phyloseq::ntaxa(prune_taxa(taxa = tax_table(ps_important_taxa)[,"Family"] %in% i,
                                                         x = ps_important_taxa))
  }
  
  for(i in imp_genus_l) {
    target_in_important_n[i]<-phyloseq::ntaxa(prune_taxa(taxa = tax_table(ps_important_taxa)[,"Genus"] %in% i,
                                                         x = ps_important_taxa))
  }
  
  
  
  
  
  
  
  
  
  # third, get the number of taxa occuring in each taxonomic group, within the full dataset 
  
  #make one empty lists to store results
  target_in_all_n<-list()
  
  # obtain the number of reads of the target taxa in the important subset
  for(i in imp_phylum_l) { #for every Phylum "i" with representatives defined as important....
    target_in_all_n[i]<-phyloseq::ntaxa(prune_taxa(taxa = tax_table(ps_all_taxa)[,"Phylum"] %in% i, # get only the taxa that belong to that particular phylum "i", then define the number of taxa in there, then save it in the empty list we just made to store the results
                                                   x = ps_all_taxa))
  }
  
  # now, perfom the same as above for every taxa level... it's hard-coded, but it works well enough. Pedro tried automating this and gave up after a few hours
  for(i in imp_class_l) {
    target_in_all_n[i]<-phyloseq::ntaxa(prune_taxa(taxa = tax_table(ps_all_taxa)[,"Class"] %in% i,
                                                   x = ps_all_taxa))
  }
  
  for(i in imp_order_l) {
    target_in_all_n[i]<-phyloseq::ntaxa(prune_taxa(taxa = tax_table(ps_all_taxa)[,"Order"] %in% i,
                                                   x = ps_all_taxa))
  }
  
  
  for(i in imp_fam_l) {
    target_in_all_n[i]<-phyloseq::ntaxa(prune_taxa(taxa = tax_table(ps_all_taxa)[,"Family"] %in% i,
                                                   x = ps_all_taxa))
  }
  
  for(i in imp_genus_l) {
    target_in_all_n[i]<-phyloseq::ntaxa(prune_taxa(taxa = tax_table(ps_all_taxa)[,"Genus"] %in% i,
                                                   x = ps_all_taxa))
  }
  
  
  
  
  
  
  
  
  
  # now, get the total number of taxa in the imporntat subset and in the full dataset
  
  # all important taxa
  all_taxa_in_important_n<-phyloseq::ntaxa(ps_important_taxa)
  
  #all taxa 
  all_taxa_in_all_n<-phyloseq::ntaxa(ps_all_taxa)
  
  
  
  
  
  
  
  
  
  # now perform fisher tests over lists; check online tutorials for fisher.test() if need
  
  # this contigency table: (summed marginal totals is equal to the total number of taxa the the full object)
  fisher_result<-mapply(function (target_in_important_n,target_in_all_n)
    fisher.test(matrix(c(target_in_important_n, 
                         all_taxa_in_important_n - target_in_important_n, 
                         target_in_all_n - target_in_important_n, 
                         all_taxa_in_all_n - all_taxa_in_important_n - target_in_all_n),
                       ncol=2),alternative = "greater" ), 
    target_in_all_n = target_in_all_n,
    target_in_important_n = target_in_important_n,
    SIMPLIFY = FALSE)
  
  return(fisher_result)
  
}

#define function that puts fisher tests in metacoder heat trees
fisher_to_heatTree<-function(fisher_output, ps_important_taxa){
#**********************************************#
############# fisher_to_heatTree ################
#**********************************************#
  
# this function takes 1 phyloseq object and the putput of the fisher_all_taxa_groups() function as 2 arguments:
# fisher_output =  The output of the function defined above, fisher_all_taxa_groups
# ps_important_taxa = a phtloseq object with the taxa classified as "important". it is the same input as you used in the function fisher_all_taxa_groups  

# this function will:
  # 1)  create a taxmap object from the phyloseq object
  # 2)  extract the p values from the fisher test and apply an fdr correction
  # 3)  extract the taxa names form the heat tree, and match it to the p values of the fisher test
  # 4)  extract the odds ratio from the fisher test and add it to the extracted p values adn taxonomies
  # 5)  creates a heat map of the important taxa, with colour for adjusted p values and node size for odds ratio

  
  
#######################################
######## make metacoder object ######## 
#######################################
imp_heat_ps<-ps_important_taxa

#remove unecessary taxonomic indo (dada2id, "S__" and" above_selected)
tax_table(imp_heat_ps)<-tax_table(imp_heat_ps)[,1:6]

# let's remove the "r__"ranks from the taxonomy, they can be useful but will pollute our plot
#tax_table(imp_heat_ps)[, colnames(tax_table(imp_heat_ps))] <- gsub(pattern = "[a-z]__", # regular expression pattern to search for
 #                                                                  x = tax_table(imp_heat_ps)[, colnames(tax_table(imp_heat_ps))], # "df"
  #                                                                 replacement = "") # replacement for pattern

# transform from phyloseq to  taxmap object
imp_heat<-parse_phyloseq(imp_heat_ps)



#######################################
######## aplly fdr to fisher ######## 
#######################################

#apply FDR correction to the p values

  #single df with all p values
  pvector<-do.call(rbind.data.frame, map(fisher_output,1))
  
  # adjust the p value with fdr, then save as a list
  adjusted_p<-p.adjust(p = pvector[[1]],
                          method = "fdr")%>%
                      as.list()
  # adjust names
  names(adjusted_p)<-names(fisher_output)

  

#this is the name that mustch match our fisher p list
taxon_id_metacoder<-lapply(imp_heat$taxa, function (x)
                                                    x$get_name())%>%
                                                    map(1)


# now turn that list into a df
taxon_id_metacoder<-do.call(rbind.data.frame, map(taxon_id_metacoder,1))

# and change column name
colnames(taxon_id_metacoder)<-"taxa_id"

# truns the p values into a dataframe
adjusted_p_input<-as.data.frame(t(as.data.frame(adjusted_p)))%>%
  rownames_to_column()

#change column names
colnames(adjusted_p_input)<-c("taxa_id", "fdr_p")
  
# now join both df
fdr_for_heatTree<-left_join(taxon_id_metacoder,
                            adjusted_p_input,
                            by = "taxa_id")



#######################################################################
################### add fold changes! ########################################
#######################################################################


# get odds ratio for each taxa
odd_list<- map(fisher_output,3)%>%
  map(1)

# truns the p values into a dataframe
odd_list<-as.data.frame(t(as.data.frame(odd_list)))%>%
  rownames_to_column()

#change column names
colnames(odd_list)<-c("taxa_id", "odds_ratio")

# now join both df
fisher_for_heatTree<-left_join(fdr_for_heatTree,
                            odd_list,
                            by = "taxa_id")




#NAs will crash metadore. let's change them with 0.9999 for now
fisher_for_heatTree[is.na(fisher_for_heatTree)]<-"1"

#change structure to numeric
fisher_for_heatTree$fdr_p<-as.numeric(fisher_for_heatTree$fdr_p)
fisher_for_heatTree$odds_ratio<-as.numeric(fisher_for_heatTree$odds_ratio)


#now let's dim p values above 0.1, or else we can get counfounded
#fisher_for_heatTree$fdr_p[fisher_for_heatTree$fdr_p>0.1]<-1







#######################################################################
############### now plot the heat tree ############### 
#######################################################################



set.seed(1)
      output<- heat_tree(imp_heat,
                 node_size = fisher_for_heatTree$odds_ratio, # n_obs is a function that calculates, in this case, the number of OTUs per taxon
                 node_color = fisher_for_heatTree$fdr_p,
                 node_label = taxon_names,
                 node_size_axis_label = "Size: oods_ratio",
                 node_color_interval = c(0, 0.15),
                 edge_color_interval = c(0, 0.15),
                 node_color_range = c("darkgreen", "seagreen", "yellowgreen", "grey"),
                 edge_color_range = c("darkgreen", "seagreen", "yellowgreen", "grey"),
                 node_color_axis_label = "Color: FDR-adjusted p",
                 layout = "davidson-harel", # The primary layout algorithm
                 initial_layout = "reingold-tilford") # The layout algorithm that initializes node locations

      return(output)
}





```

## 6.3 - check some of the proportions we will test
is a specific taxonomy overly frequent in the "important" dataset when compared to the taxonomies of the ASV that were NOT defined as important?

*note* that this phyloseq input is based on the original phyloseq object, that still contains the ranks as p__Proteobacteria, o__Rhizobiales, etc

```{r message=FALSE, warning=FALSE}


# how many rhizobiales do we have in full set of 963 ASVs of A. thaliana?
ntaxa(physeq = subset_taxa(ps_l$At, Order == "o__Rhizobiales"))

# how many rhizobiales do we have in the group of 114 "important" ASVs for A. thaliana?
ntaxa(physeq = subset_taxa(imp_ASV_ps_l$At, Order == "o__Rhizobiales"))

# how many rhizobiales do we have in the set of 849 A. thaliana ASVs that were not tagged as important ?
unimp_ASV_ps_at<-prune_taxa(!(taxa_names(ps_l$At) %in% imp_asv_list$At), ps_l$At)
ntaxa(physeq = subset_taxa(unimp_ASV_ps_at, Order == "o__Rhizobiales"))



```
is 18 in 114 (~15%) similar to 63 in 849 (~7%), considering we have in total 18+63 (81) rhizobiales in 114+849 (983) bASVs? if these proportions are statistically different, rhizobiales may be over represented in the important ASV set. 

What are we actually testing here? if the important ASVs are just a random subset of the complete dataset, the proportion of rhizobiales in both datasets should be similar

In other words: the chance that these many rhizobiales were tagged as "important" *just because there is a lot of rhizobiales in the full/background dataset* is too small.



## 6.4 - calculate proportions of the fisher test

by running the functions defined in chunk #6.2, we test the proportions stated in chunk # 6.3 - on all taxonomic levels of your input phyloseq object

```{r, message = FALSE, warning = FALSE}
# run a fisher test comparin these proportions at all taxonomic levels
fisher_output_at<-fisher_all_taxa_groups(ps_important_taxa = imp_ASV_ps_l$At,
                                         ps_all_taxa = ps_l$At)

#check raw ouput of fisher tests for rhizobiales
fisher_output_at[1:3]
fisher_output_at$o__Rhizobiales

# with map() we can easely extract key values from this output, like so:
str(fisher_output_at$o__Rhizobiales) # here we see that p values are the first list element of each taxa ouput
map(fisher_output_at, 1) # here we extarct the first list element of each taxa in the list (p values)
map(fisher_output_at, 3) # here we extarct the third list element of each taxa in the list (odds ratio)



```

## 6.5 - calculate proportions of the fisher test

this functions will now take p values and oods ratio out of the fisher test output and into the heat tree

```{r, message = FALSE, warning = FALSE, results='hide'}
# extract p values and odds ration from the fisher tests and put it into the heat tree
fisher_to_heatTree(fisher_output = fisher_output_at, 
                   ps_important_taxa = imp_ASV_ps_l$At)

```

What are we seeing here? each tree shows the full taxonomy of all ASVs that were "important" because they are:
1) differentially abundant in stress treatment pairwise comparison, OR;
2) predictors of stress treatments in a random forest, OR;
3) defined as keystone taxa, module hubs or module connectors in a network

The colored taxa shows adjusted p-values from the fisher test (p >0.15 is turned to grey)

By comparing the full taxonomies of these important ASVs with the the full taxonomies of all ASVs that were NOT "important", we see that o__Rhizobiales and f__Devosiaceae are much too frequent in the "important" ASV dataset. This is likely because they consistently have major roles in stress response and community structure, wich was determined by these 3 analysis methods. note that for this summary we don't consider ASV abundance (number of reads/sequences of each ASV) as it was already accounted for in the other 3 methods.


## 6.6 - make one fisher summary heat tree per species
now, run these custom functions over lists of phyloseq objects separated by species with mapply

```{r message=FALSE, warning=FALSE, results='hide'}

# run the custom function voer 2 lists of philoseq objects, one with imporntat taxa and other with the full taxa (for every partition)
fisher_result_l<-mapply(function (list_1,list_2)
                   fisher_all_taxa_groups(ps_important_taxa = list_1, 
                                          ps_all_taxa = list_2),
                   list_1 = imp_ASV_ps_l,
                   list_2 = ps_l,
                   SIMPLIFY = FALSE)


#run the custom function on a list of 3 species
fisher_summaries_3l<-mapply(function(list_1,list_2)
    fisher_to_heatTree(fisher_output = list_1,
                       ps_important_taxa = list_2),
    list_1 = fisher_result_l,
    list_2 = imp_ASV_ps_l,
    SIMPLIFY = FALSE)


```

## 6.7 - Check summary output

To simply the evaluation, let's look into the output species by species
```{r message=FALSE, warning=FALSE }

# summary in A. thaliana
fisher_summaries_3l$At

# summary in B oleraceae
fisher_summaries_3l$Bo_M

# summary in I. tinctoria
fisher_summaries_3l$It

```

What is the output we have here? let's word it in different ways

In A. thaliana, o__Rhizobiales and f__Devosiaceae are found too often in the importnat ASV subset

In B oleraceae, the proportion of o__Rhizobiales and f__Beijerinckiaceae is significantly higher in the important ASV dataset when considering the full ASV dataset

Do you see that branch from o__Streptomycetales on in I. tinctoria? considering the full dataset, there are too many representatives of that branch in the imporant ASV subset

These summary trees were not particularly highlighted as significant because the base operations to calculate differential abundance, random forest, and networks, was based on a much larger dataset with 70k ASVs, and I did not have the time to re-run it for this 1k ASV dataset.

# That's it, thank you for your time!
I hope you found the workshop insightful and that you will find the code useful as a template you can improve. feel free to share this with collegues. as you know, you will need many microbiome tutorials for a complete, updated analysis. 






# BONUS FOR THE CURIOUS
Are you curious about all the data wrangling of these 2 custom functions? here you can execute a hard-coded version of the function, where you can visualize each object step by step.


```{r eval=FALSE, include=FALSE}

#hard-code input arguments of fisher_all_taxa_groups()
ps_important_taxa<-imp_ASV_ps_l$At
ps_all_taxa<-ps_l$At

 
# first, get the taxonomic groups of the taxa defined as important
  
  #this will get us a list of (taxa_level) that appears in the important subset more than once
  imp_phylum_l<-as.character(tax_table(ps_important_taxa)[,"Phylum"]) # gets a char vector  of "families" shown as relevant
  imp_phylum_l<-imp_phylum_l[imp_phylum_l != "p__uncultured"] # removes any taxonomy set as "uncultured"
  imp_phylum_l<-names(which(table(imp_phylum_l)>2))%>% # get names of taxa that occur ate least 1 time NOTE: CHANGED FROM >2
    na.omit()%>% #remove NA from classifications
    unique()%>%  #dereplicates repetitive values (avoids "f__Chitinophagaceae" "f__Chitinophagaceae" "f__Oxalobacteraceae")
    as.list(c()) # save the dereplicated values as a list
  
  # now, perfom the same as above for every taxa level... it's hard-coded, but it works well enough. Pedro tried automating this and gave up after a few hours
  imp_class_l<-as.character(tax_table(ps_important_taxa)[,"Class"]) 
  imp_class_l<-imp_class_l[imp_class_l != "c__uncultured"] 
  imp_class_l<-names(which(table(imp_class_l)>2))%>% 
    na.omit()%>% 
    unique()%>%  
    as.list(c()) 
  
  imp_order_l<-as.character(tax_table(ps_important_taxa)[,"Order"])
  imp_order_l<-imp_order_l[imp_order_l != "o__uncultured"]
  imp_order_l<-names(which(table(imp_order_l)>2))%>%
    na.omit()%>% 
    unique()%>%
    as.list(c()) 
  
  imp_fam_l<-as.character(tax_table(ps_important_taxa)[,"Family"])
  imp_fam_l<-imp_fam_l[imp_fam_l != "f__uncultured"]
  imp_fam_l<-names(which(table(imp_fam_l)>2))%>%
    na.omit()%>% 
    unique()%>% 
    as.list(c()) 
  
  imp_genus_l<-as.character(tax_table(ps_important_taxa)[,"Genus"])
  imp_genus_l<-imp_genus_l[imp_genus_l != "g__uncultured"]
  imp_genus_l<-names(which(table(imp_genus_l)>2))%>%
    na.omit()%>% 
    unique()%>% 
    as.list(c()) 
  

  
  
  
  
  # second, get the number of taxa occuring in each taxonomic group, within the imporntat taxa subset
  # note: using phyloseq::subset_taxa with a for loop will cause issues as your taxa is intepreted as "i"! to avoid this, use phyloseq::prune_taxa instead
  
  
  
  #make one empty lists to store results
  target_in_important_n<-list()
  
  # obtain the number of reads of the target taxa in the important subset
  for(i in imp_phylum_l) { #for every Phylum "i" with representatives defined as important....
    target_in_important_n[i]<-phyloseq::ntaxa(prune_taxa(taxa = tax_table(ps_important_taxa)[,"Phylum"] %in% i, # get only the taxa that belong to that particular phylum "i", then define the number of taxa in there, then save it in the empty list we just made to store the results
                                                         x = ps_important_taxa))
  }
  
  # now, perfom the same as above for every taxa level... it's hard-coded, but it works well enough. Pedro tried automating this and gave up after a few hours
  for(i in imp_class_l) {
    target_in_important_n[i]<-phyloseq::ntaxa(prune_taxa(taxa = tax_table(ps_important_taxa)[,"Class"] %in% i,
                                                         x = ps_important_taxa))
  }
  
  for(i in imp_order_l) {
    target_in_important_n[i]<-phyloseq::ntaxa(prune_taxa(taxa = tax_table(ps_important_taxa)[,"Order"] %in% i,
                                                         x = ps_important_taxa))
  }
  
  
  for(i in imp_fam_l) {
    target_in_important_n[i]<-phyloseq::ntaxa(prune_taxa(taxa = tax_table(ps_important_taxa)[,"Family"] %in% i,
                                                         x = ps_important_taxa))
  }
  
  for(i in imp_genus_l) {
    target_in_important_n[i]<-phyloseq::ntaxa(prune_taxa(taxa = tax_table(ps_important_taxa)[,"Genus"] %in% i,
                                                         x = ps_important_taxa))
  }
  
  
  
  
  
  
  
  
  
  # third, get the number of taxa occuring in each taxonomic group, within the full dataset 
  
  #make one empty lists to store results
  target_in_all_n<-list()
  
  # obtain the number of reads of the target taxa in the important subset
  for(i in imp_phylum_l) { #for every Phylum "i" with representatives defined as important....
    target_in_all_n[i]<-phyloseq::ntaxa(prune_taxa(taxa = tax_table(ps_all_taxa)[,"Phylum"] %in% i, # get only the taxa that belong to that particular phylum "i", then define the number of taxa in there, then save it in the empty list we just made to store the results
                                                   x = ps_all_taxa))
  }
  
  # now, perfom the same as above for every taxa level... it's hard-coded, but it works well enough. Pedro tried automating this and gave up after a few hours
  for(i in imp_class_l) {
    target_in_all_n[i]<-phyloseq::ntaxa(prune_taxa(taxa = tax_table(ps_all_taxa)[,"Class"] %in% i,
                                                   x = ps_all_taxa))
  }
  
  for(i in imp_order_l) {
    target_in_all_n[i]<-phyloseq::ntaxa(prune_taxa(taxa = tax_table(ps_all_taxa)[,"Order"] %in% i,
                                                   x = ps_all_taxa))
  }
  
  
  for(i in imp_fam_l) {
    target_in_all_n[i]<-phyloseq::ntaxa(prune_taxa(taxa = tax_table(ps_all_taxa)[,"Family"] %in% i,
                                                   x = ps_all_taxa))
  }
  
  for(i in imp_genus_l) {
    target_in_all_n[i]<-phyloseq::ntaxa(prune_taxa(taxa = tax_table(ps_all_taxa)[,"Genus"] %in% i,
                                                   x = ps_all_taxa))
  }
  
  
  
  
  
  
  
  
  
  # now, get the total number of taxa in the imporntat subset and in the full dataset
  
  # all important taxa
  all_taxa_in_important_n<-phyloseq::ntaxa(ps_important_taxa)
  
  #all taxa 
  all_taxa_in_all_n<-phyloseq::ntaxa(ps_all_taxa)
  
  
  
  
  
  
  
  
  
  # now perform fisher tests over lists; check online tutorials for fisher.test() if need
  
  # this contigency table: (summed marginal totals is equal to the total number of taxa the the full object)
  fisher_result<-mapply(function (target_in_important_n,target_in_all_n)
    fisher.test(matrix(c(target_in_important_n, 
                         all_taxa_in_important_n - target_in_important_n, 
                         target_in_all_n - target_in_important_n, 
                         all_taxa_in_all_n - all_taxa_in_important_n - target_in_all_n),
                       ncol=2),alternative = "greater" ), 
    target_in_all_n = target_in_all_n,
    target_in_important_n = target_in_important_n,
    SIMPLIFY = FALSE)

  
  
#output of the function
  fisher_result

```


```{r}



#hard-code input arguments of fisher_all_taxa_groups()
ps_important_taxa<-imp_ASV_ps_l$At
fisher_output<-fisher_result



#######################################
######## make metacoder object ######## 
#######################################
imp_heat_ps<-ps_important_taxa

#remove unecessary taxonomic indo (dada2id, "S__" and" above_selected)
tax_table(imp_heat_ps)<-tax_table(imp_heat_ps)[,1:6]

# let's remove the "r__"ranks from the taxonomy, they can be useful but will pollute our plot
tax_table(imp_heat_ps)[, colnames(tax_table(imp_heat_ps))] <- gsub(pattern = "[a-z]__", # regular expression pattern to search for
                                                                   x = tax_table(imp_heat_ps)[, colnames(tax_table(imp_heat_ps))], # "df"
                                                                   replacement = "") # replacement for pattern

# transform from phyloseq to  taxmap object
imp_heat<-parse_phyloseq(imp_heat_ps)



#######################################
######## aplly fdr to fisher ######## 
#######################################

#apply FDR correction to the p values

  #single df with all p values
  pvector<-do.call(rbind.data.frame, map(fisher_output,1))
  
  # adjust the p value with fdr, then save as a list
  adjusted_p<-p.adjust(p = pvector[[1]],
                          method = "fdr")%>%
                      as.list()
  # adjust names
  names(adjusted_p)<-names(fisher_output)

  

#this is the name that mustch match our fisher p list
taxon_id_metacoder<-lapply(imp_heat$taxa, function (x)
                                                    x$get_name())%>%
                                                    map(1)


# now turn that list into a df
taxon_id_metacoder<-do.call(rbind.data.frame, map(taxon_id_metacoder,1))

# and change column name
colnames(taxon_id_metacoder)<-"taxa_id"

# truns the p values into a dataframe
adjusted_p_input<-as.data.frame(t(as.data.frame(adjusted_p)))%>%
  rownames_to_column()

#change column names
colnames(adjusted_p_input)<-c("taxa_id", "fdr_p")
  
# now join both df
fdr_for_heatTree<-left_join(taxon_id_metacoder,
                            adjusted_p_input,
                            by = "taxa_id")



#######################################################################
################### add fold changes! ########################################
#######################################################################


# get odds ratio for each taxa
odd_list<- map(fisher_output,3)%>%
  map(1)

# truns the p values into a dataframe
odd_list<-as.data.frame(t(as.data.frame(odd_list)))%>%
  rownames_to_column()

#change column names
colnames(odd_list)<-c("taxa_id", "odds_ratio")

# now join both df
fisher_for_heatTree<-left_join(fdr_for_heatTree,
                            odd_list,
                            by = "taxa_id")




#NAs will crash metadore. let's change them with 0.9999 for now
fisher_for_heatTree[is.na(fisher_for_heatTree)]<-"1"

#change structure to numeric
fisher_for_heatTree$fdr_p<-as.numeric(fisher_for_heatTree$fdr_p)
fisher_for_heatTree$odds_ratio<-as.numeric(fisher_for_heatTree$odds_ratio)


#now let's dim p values above 0.1, or else we can get counfounded
#fisher_for_heatTree$fdr_p[fisher_for_heatTree$fdr_p>0.1]<-1







#######################################################################
############### now plot the heat tree ############### 
#######################################################################



set.seed(1)
      output<- heat_tree(imp_heat,
                 node_size = fisher_for_heatTree$odds_ratio, # n_obs is a function that calculates, in this case, the number of OTUs per taxon
                 node_color = fisher_for_heatTree$fdr_p,
                 node_label = taxon_names,
                 node_size_axis_label = "Size: oods_ratio",
                 node_color_interval = c(0, 0.15),
                 edge_color_interval = c(0, 0.15),
                 node_color_range = c("darkgreen", "seagreen", "yellowgreen", "grey"),
                 edge_color_range = c("darkgreen", "seagreen", "yellowgreen", "grey"),
                 node_color_axis_label = "Color: FDR-adjusted p",
                 layout = "davidson-harel", # The primary layout algorithm
                 initial_layout = "reingold-tilford") # The layout algorithm that initializes node locations

```

