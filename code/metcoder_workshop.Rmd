---
title: "metacoder_workshop"
output: html_document
date: "2022-10-25"
editor_options: 
  chunk_output_type: console
---

# 1.0 - install packages, load libraries

Here we source the bit of code that performs this operation. essentially, this one-line command runs an entire R script file. This can be handy when you load the same libraries in different steps of your analysis

```{r}

source("./code/install_packages_load_libraries.R")

```

# 2.0 - load and check data

Here we will load  data from 3 species in the Brassicacea family experiment: Arabdopsis thaliana, Brassica oleraceae and Isatis tinctoria    . This data has been heavily filtered to reduce complexity and size. 

You will see that the data is stored as a list of 3 phyloseq objects. we can acess this in different ways

```{r}
# load object
load("./data/ps_rarefied.Rdata")

#check ps object
ps_rarefied # full ps object
otu_table(ps_rarefied)[1:10,1:10] # 10 first rows across 10 first columns
tax_table(ps_rarefied)[1:10,] # 10 first rows across all columns
ps_rarefied@sam_data [1:10,1:10]# metadata


``` 


# 3.0 - create a single taxmap object for a single heat tree

For a simple start, let's create individual heat trees from an individual plyloseq object
```{r}

#######################################
######## make metacoder object ######## 
#######################################

# make a copy of you rarefied ps object
ps_rarefied_filt<-ps_rarefied

#remove unecessary taxonomic info (dada2id, "s__" and "ASV_id") by updating the tax table with a subset of the tax table
tax_table(ps_rarefied_filt)<-tax_table(ps_rarefied_filt)[,1:6]


# let's remove the "r__"ranks from the taxonomy, they can be useful but will pollute our plot
tax_table(ps_rarefied_filt)[, colnames(tax_table(ps_rarefied_filt))] <- gsub(pattern = "[a-z]__", # regular expression pattern to search for
                                                                   x = tax_table(ps_rarefied_filt)[, colnames(tax_table(ps_rarefied_filt))], # "df"
                                                                   replacement = "") # replacement for pattern
# transform from phyloseq to taxmap object
taxmap_obj<-parse_phyloseq(ps_rarefied_filt)


```

## 3.1 - EXERCISE check taxmap object you just created
```{r}
# the taxmap object is a data container, just like phyloseq
taxmap_obj

# this object has much more than what you can see on one print, just like much other R output you generate. 
# EXERCISE: explroe taxmap_obj with "$" or "@" and tab-completion

taxmap_obj$data$otu_table # otu tables...


```

## 3.2 - create the heat tree visualization

Now we can create a heat tree, with colors indicating the number of sequences in each taxa. 

The first tree is actually quite busy - depending on your goal, you might want to further filter the input ASVs to a smaller subset like all differentially abudnant ASVs or features defined as important predictors in random forest

```{r}

# create a heat tree!
set.seed(1) # set a seed so the layout can be exactly the same every time
heat_tree(.input = taxmap_obj, # your taxmap object from the metacoder package
          node_size = n_obs, # n_obs is a function that calculates the number of OTUs per taxon 
          node_color = n_obs, # this fucntion from metacoder is called with non-standard evaluation (therefore, no arguments)
          node_label = taxon_names, # labels for the taxons
          layout = "davidson-harel", # The primary layout algorithm
          initial_layout = "reingold-tilford", # The layout algorithm that initializes node locations
          output_file = "./results/heat_tree_test.pdf") # A PDF file you will export this plot to



```

# EXERCISE - check what's produced with the n_obs argument/function and also check the taxa names 

```{r}

#n_obs is a function that takesyour taxmap object as input, and return the number of sequences in each taxa
n_obs(taxmap_obj)

#in metacoder, ab, ac, ad, etc refer each to a different taxonomy
taxmap_obj$taxa



```

## 3.3 - Remove some taxa the heat tree visualization

It might be too dense/complex to look, so let's remove taxa names that can be  unfamiliar like  "phylum NB1-J"

```{r}

# create a heat cleaner tree!
taxmap_obj %>%
  metacoder::filter_taxa(grepl(pattern = "^[a-zA-Z]+$", taxon_names)) %>% # remove "odd" taxa
  heat_tree(node_label = taxon_names,
            node_size = n_obs,
            node_color = n_obs,
            layout = "davidson-harel",
            initial_layout = "reingold-tilford",
            output_file = "./results/heat_tree_test_cleaner.pdf")



```




## 3.4 - modify the tree with available options

## 3.4.1 -  truncate at order level

This tree stops at Order level
```{r}

# create a heat cleaner tree!
taxmap_obj %>%
  metacoder::filter_taxa(grepl(pattern = "^[a-zA-Z]+$", taxon_names)) %>% # remove "odd" taxa
  metacoder::filter_taxa(taxon_ranks == "Order", supertaxa = TRUE) %>% # subset to the Order rank
  heat_tree(node_label = taxon_names,
            node_size = n_obs,
            node_color = n_obs,
            layout = "davidson-harel",
            initial_layout = "reingold-tilford",
            output_file = "./results/heat_tree_order.pdf")

```

## 3.4.2 - make individual roots for specific taxonomic groups

This tree has a separated root at different taxonomic levels
```{r}

# create a heat cleaner tree!
taxmap_obj %>%
  metacoder::filter_taxa(grepl(pattern = "^[a-zA-Z]+$", taxon_names)) %>% # remove "odd" taxa
  metacoder::filter_taxa(taxon_names %in% c("Rhizobiales", "Firmicutes", "Actinobacteria", "Comamonadaceae"),
              subtaxa = TRUE, 
              supertaxa = FALSE) %>% 
  heat_tree(node_label = taxon_names,
            node_size = n_obs,
            node_color = n_obs,
            layout = "davidson-harel",
            initial_layout = "reingold-tilford",
            output_file = "./results/heat_tree_sep_roots.pdf")

```




## 3.5 - Compare 2 groups of samples
lets now compare ASV abundances between two groups of samples, such as plant species in brassicaceae lineage I and II (Sp_Lineage_Walden). 

### 3.5.1 -  calculate taxon abundance
"tax_abund" is added as a data layer of the taxmap object. it defines the number of sequences on every single taxon  - all phyla, all classes, orders... this is different from counts of every single ASV! this data layer is needed on the next step.


```{r}
#get abundance per taxon
taxmap_obj$data$tax_abund<-calc_taxon_abund(obj = taxmap_obj, # the taxmap object
                                            data = "otu_table", # layer of data table to use
                                            cols = taxmap_obj$data$sample_data$sample_id) #sample anmes

#check the new data layer you created. note that "aab" refers to "k__Bacteria",  and "aac" to "p__Proteobacteria".  
taxmap_obj$data$tax_abund

#quickly compare those values to the OTU table to see the differnce:
taxmap_obj$data$otu_table

```

### 3.5.2 -  calculate taxon prevalence/occumpancy

here we define taxa "occurrence" by determining in how many samples of each group they appear
```{r}

#get occurrence of per lineage
taxmap_obj$data$tax_occ_2lineages <- calc_n_samples(obj = taxmap_obj, 
                                                    data = "tax_abund", 
                                                    cols = taxmap_obj$data$sample_data$sample_id,
                                                    groups = taxmap_obj$data$sample_data$Sp_Lineage_Walden) # What category each sample is



#check the object. it shows how many times a taxon is represented in lineage I or II
taxmap_obj$data$tax_occ_2lineages

```

### 3.5.3 -  calculate log fold changes between two groups
Here we see log fold changes

```{r}
# this will calculate log2 median ratios and p values for a wilcoxcon test within taxas in this lineage
taxmap_obj$data$diff_table_2lineages <- compare_groups(obj = taxmap_obj,
                                                      data = "tax_abund",
                                                      cols = taxmap_obj$data$sample_data$sample_id, 
                                                      groups = taxmap_obj$data$sample_data$Sp_Lineage_Walden) 

#check the object.
taxmap_obj$data$diff_table_2lineages

```

### 3.5.3 - plot heat tree showing log-fold differences
tan indicates lineage II, cyan indicates lineage I

```{r}

taxmap_obj %>%
  metacoder::filter_taxa(grepl(pattern = "^[a-zA-Z]+$", taxon_names)) %>% # remove "odd" taxa
  heat_tree(node_label = taxon_names,
            node_size = n_obs,
            node_color = log2_median_ratio,
            node_color_interval = c(-3, 3), # The range of `log2_median_ratio` to display
            node_color_range = c("cyan", "gray", "tan"), # The color palette used
            layout = "davidson-harel",
            node_color_axis_label = "Log2 ratio, cyan for Lineage I",
            initial_layout = "reingold-tilford",
            output_file = "./results/heat_tree_diff_lineages.pdf")


```


# EXERCISE
We just created a lot of new layers to the data of our taxmap object. can you dfind them using $ adn tab-completion?

```{r}

#check the names of the data layers we ahve
names(taxmap_obj$data)

# check one of tehse data layers....
taxmap_obj$data
  
```



### 3.5.3 - supress non-significant differences and plot log changes again 
this plot indicates log fold changes, but includes p values > 0.05. let's run any non-significat differences into a median log ratio of zero, shading them as grey in the plot

```{r}

# set differential log ratio to 0 based on p values below 0.05
taxmap_obj$data$diff_table_2lineages$log2_median_ratio[taxmap_obj$data$diff_table_2lineages$wilcox_p_value > 0.05] <- 0

# plot the heatmap
taxmap_obj %>%
  metacoder::filter_taxa(grepl(pattern = "^[a-zA-Z]+$", taxon_names)) %>% # remove "odd" taxa
  heat_tree(node_label = taxon_names,
            node_size = n_obs,
            node_color = log2_median_ratio,
            node_color_interval = c(-3, 3), # The range of `log2_median_ratio` to display
            node_color_range = c("cyan", "gray", "tan"), # The color palette used
            layout = "davidson-harel",
            node_color_axis_label = "Log2 ratio, cyan for Lineage I",
            initial_layout = "reingold-tilford",
            output_file = "./results/heat_tree_diff_lineages_pcut.pdf")






```

From this figure, we could see a larger presence of low-diversity phyla in lineage I (cyan). lineage II has a clear increase in Sphingomonadaceae. both lineages seem to be colonized by several, but different, bacteroidia and actinobacteria. Family Comamonadaceae and Chitinophagaceae seem to be the most diverse


## 3.6 - Compare 3 or more groups of samples

If you have more than 2 groups, like we have 3 different stresses, you can plot a matrix of heat trees with a dedicated function from the same package. before we do that, let's first calculate taxon abundance, prevalence, and log-fold changes like we did in chunks 3.5.1 to 3.5.3

### 3.6.1 - calculate abudance, prevalence and log-fold in  3 treatment groups

```{r}

#abundance per taxon was already calculated in chunk 3.5.1. we use the same data so tehre is no need to re-calculate it. let's just check the object
taxmap_obj$data$tax_abund

#get occurrence of ASVs per treatment
taxmap_obj$data$tax_occ_3treatments <- calc_n_samples(obj = taxmap_obj, 
                                                      data = "tax_abund", 
                                                      cols = taxmap_obj$data$sample_data$sample_id,
                                                      groups = taxmap_obj$data$sample_data$Stress) # now refer to Stress, that has 3 groups

# calculate log2 median ratios and p values for a wilcoxcon test within taxas in this stress treatment groups
taxmap_obj$data$diff_table_3treatments <- compare_groups(obj = taxmap_obj,
                                                        data = "tax_abund",
                                                        cols = taxmap_obj$data$sample_data$sample_id, 
                                                        groups = taxmap_obj$data$sample_data$Stress) 

# set differential log ratio to 0 based on adjusted p values
taxmap_obj$data$diff_table_3treatments$log2_median_ratio[taxmap_obj$data$diff_table_3treatments$wilcox_p_value > 0.05] <- 0

# because of potential ambiguity in non-standard evaluation, we should change this column name. this is only needed because of the column taxmap_obj$data$diff_table_2lineages$log2_median_ratio we created in chunk 3.5.3 
names(taxmap_obj$data$diff_table_3treatments)[4]<-"log2_median_ratio_stress"



```


### 3.6.2 - Plot a matrix of heat trees
Now that we have log-fold differences in pariwise treatment comparisons, let's compare them in a matrix of heat trees

```{r}

#plot matrix tree
set.seed(1)
heat_tree_matrix(taxmap_obj,
                 data = "diff_table_3treatments", # this is the table with the data you want to plot
                 node_size = n_obs, # n_obs is a function that calculates, in this case, the number of OTUs per taxon
                 node_label = taxon_names,
                 node_color = log2_median_ratio_stress, # A column from `taxmap_obj$data$diff_table_3treatments`
                 node_color_range = diverging_palette(), # The built-in palette for diverging data
                 node_color_trans = "linear", # The default is scaled by circle area
                 node_color_interval = c(-3, 3), # The range of `log2_median_ratio` to display
                 edge_color_interval = c(-3, 3), # The range of `log2_median_ratio` to display
                 node_size_axis_label = "Number of OTUs",
                 node_color_axis_label = "Log2 ratio median proportions",
                 layout = "davidson-harel", # The primary layout algorithm
                 initial_layout = "reingold-tilford", # The layout algorithm that initializes node locations
                 output_file = "./results/matrix_heat_tree.pdf") # Saves the plot as a pdf file

```

# EXERCISE
by changeing the code above, Make a matrix fo heat trees that plots the differences between the 3 plant species we are using. The metadata for that is present in the metadata column "sp_full_name". which alphaproteobacteria are more common in Brassica oleracea than Isatis tinctoria?



## 3.7 - create a matrix of heat trees from a phyloseq object with a single function

These trees are interesting, but as you start exploring real data and multiple options you will need a more efficiency way of running all this code. for this, we create a custom function that handles all of it at once, 

### 3.7.1 - Define a custom function

this custom function will: 

1 - truncate the taxonomy table to genus level,  
2 - remove the g__ and f__ etc from taxonomy table
3 - parse the phyloseq object into a taxmap object, 
4 - calculate taxa occurence, abudance and log-fold differences between groups of samples that you define
5 - plot a heat tree

It's arguments are
1 - ps_object = a phyloseq object
2 - sample_group = a (quoted) column from the sample metadata that you want to compare

The function will count the number of different groups in your metadata column to decide if it will plot a heat tree (2 treatments/groups) or matrix of heat trees (3+ treatments). the function should fail if your metadata only has 1 sample group!


```{r}

phyloseq_to_heat_tree_matrix<-function(ps_object, sample_group){
  # this function output is a heat trees comparing metadata. the input is based on a phyloseq object
  # ps object =  a phyloseq object, containing sample metadata, otu table, and taxonomy table
  # sample_group = the name of a column in your emtadata that you want to compare in the heat tree. it has to be quoted.
  # this function will create a matrix of heat trees if your metadata has more than 2 groups. it should fail if it has only 1 group
  

#remove unecessary taxonomic info (dada2id, "s__" and "ASV_id) by updating the tax table with a subset of the tax table
tax_table(ps_object)<-tax_table(ps_object)[,1:6]


# let's remove the "r__"ranks from the taxonomy, they can be useful but will pollute our plot
tax_table(ps_object)[, colnames(tax_table(ps_object))] <- gsub(pattern = "[a-z]__", # regular expression pattern to search for
                                                                   x = tax_table(ps_object)[, colnames(tax_table(ps_object))], # "df"
                                                                   replacement = "") # replacement for pattern
# transform from phyloseq to taxmap object
taxmap_obj<-parse_phyloseq(ps_object)

#get abundance per taxon
taxmap_obj$data$tax_abund<-calc_taxon_abund(obj = taxmap_obj, 
                                      data = "otu_table",
                                      cols = taxmap_obj$data$sample_data$sample_id) 

#get occurrence of ASVs per treatment
# the sample groups needs some wrangling to fit within the soft code of the function
taxmap_obj$data$tax_occ<- calc_n_samples(obj = taxmap_obj, 
                                                      data = "tax_abund", 
                                                      cols = taxmap_obj$data$sample_data$sample_id,
                                                      groups = taxmap_obj$data$sample_data[colnames(taxmap_obj$data$sample_data)==sample_group][[1]]) 

# calculate log2 median ratios and p values for a wilcoxcon test within taxas in this stress treatment groups
# the sample groups needs some wrangling to fit within the soft code of the function
taxmap_obj$data$diff_table <- compare_groups(obj = taxmap_obj,
                                                        data = "tax_abund",
                                                        cols = taxmap_obj$data$sample_data$sample_id, 
                                                        groups = taxmap_obj$data$sample_data[colnames(taxmap_obj$data$sample_data)==sample_group][[1]]) 

# set differential log ratio to 0 based on adjusted p values
taxmap_obj$data$diff_table$log2_median_ratio[taxmap_obj$data$diff_table$wilcox_p_value > 0.05] <- 0

# define number of compared factors
factors_compared<-taxmap_obj$data$sample_data[colnames(taxmap_obj$data$sample_data)==sample_group][[1]] 

# draw the plot based on an if else statement: if there are 2 groups, plot a a heat tree comparing abundances between both groups, else plot a matrix of ehat trees. this function will fail if you only have 1 sample group! 


if (length(unique(factors_compared)) == 2) {

set.seed(1)
 output<- taxmap_obj %>%
heat_tree(
            node_label = taxon_names,
      #      data = "diff_table", 
            node_size = n_obs,
            node_color = log2_median_ratio,
            node_color_interval = c(-3, 3), # The range of `log2_median_ratio` to display
            node_color_range = c("cyan", "gray", "tan"), # The color palette used
            layout = "davidson-harel",
            initial_layout = "reingold-tilford")

 } else {

set.seed(1)
output<-heat_tree_matrix(taxmap_obj,
                         data = "diff_table", # this is the table with the data you want to plot
                         node_size = n_obs, # n_obs is a function that calculates, in this case, the number of OTUs per taxon
                         node_label = taxon_names,
                         node_color = log2_median_ratio, # A column from `taxmap_obj$data$diff_table_3treatments`
                         node_color_range = diverging_palette(), # The built-in palette for diverging data
                         node_color_interval = c(-3, 3), # The range of `log2_median_ratio` to display
                         edge_color_interval = c(-3, 3), # The range of `log2_median_ratio` to display
                         node_size_axis_label = "Number of OTUs",
                         node_color_axis_label = "Log2 ratio median proportions",
                         layout = "davidson-harel", # The primary layout algorithm
                         initial_layout = "reingold-tilford") # The layout algorithm that initializes node locations

   
   
 }


# clearly define the output object you will get from the function
return(output)   


}

```

### 3.7.2 - creating heat trees from a custom function

Now that we defined a new function that takes a phyloseq object as a data input and a column of the metadata as an argument, we can more easely produce heat trees across the variables.



```{r}
# run custom function
heat_tree_stress<-phyloseq_to_heat_tree_matrix(ps_object = ps_rarefied_filt, sample_group = "Stress")
heat_tree_lineage<-phyloseq_to_heat_tree_matrix(ps_object = ps_rarefied_filt, sample_group = "Sp_Lineage_Walden")





```



### 3.7.3 - EXERCISE

#### 3.7.3.1 - make more heat trees!

Now produce new heat tree, based on metadata like "Sp_full_name", "greenhouse_compartment" or "Speed"!

```{r}
#check sample metadata and create new comparisons
ps_rarefied@sam_data

# put new metadata to define comparisons
new_heat_tree1<-phyloseq_to_heat_tree_matrix(ps_object = ps_rarefied_filt, sample_group = "")


```

#### 3.7.3.2 - see Burkholderiales ASVs with custom fucntion

Our trees so far stopped at genus level, because ploting 2000 ASVs would overcrowd the plot. *Show the "Sp_full_name" effect at ASV level, but only on Burkholderiales and Rhizobiales. What do you have to change, and where?* You can copy-paste and adjust the code we saw above,  make a new version of the custom function

```{r}


```

#### 3.7.3.2 - remove kingdom from taxonomy table

Our trees so far have k__Bacteria as a shared root. *What will happen if you remove that taxonomic information? to make this change, What do you have to alter?* You can copy-paste and adjust the code we saw above,  make a new version of the custom function

```{r}


```





# 4.0 - create a list of taxmap objects for a single heat tree
Now that we have a function that takes a single phyloseq object as input, let's run it across all the species in the dataset


## 4.1 - create a list of phyloseq objects
First, let's split the phyloseq object into a list of phyloseq objects according the species


```{r}
# turn a ps object into a list f ps objects
ps_l<- metagMisc::phyloseq_sep_variable(ps_rarefied_filt, variable = "Sp_abb_name")


```


## 4.2 - check list of phyloseq objects
Let's check the list we just created. there are different ways we can do this


```{r}
# check object, which is a list of phyloseq objects (ps_l)
ps_l

# acess the Arabidosps dataset, then check taxonomy
ps_l$At@tax_table

# check metadata of the second list object
sample_data(object = ps_l[[2]])

```


## 4.4 - run custom function on list of phyloseq objects
lapply (list apply) will apply a function over a list. as we have a list of phyloseq objects now, it will be easy to produce several matrixes of heat trees. when working on lists of 33 species we learned that 33 plots are hardly helpful. still, the code and the concept (make a custom function that uses a phyloseq object as input, then run over a list with lapply) can be very useful on your own analysis

```{r}
# run the custom function over a list of phyloseq objects... it can take a moment
heat_tree_stress_l<-lapply(ps_l, function(x)  
  phyloseq_to_heat_tree_matrix (ps_object = x, sample_group = "Stress"))

heat_tree_stress_l<-ggarrange(heat_tree_stress_l$At,
         heat_tree_stress_l$Bo_M,
         heat_tree_stress_l$It,
         labels = c(names(heat_tree_stress_l)))

```




# 5.0 adding external data to the heat trees
What if we want to visualize other types of taxa-associated data, like p values from deseq2, importance in random forest predictions, distances in an ordination, or degree in a network? You can do that, as long as the vector of values you use as node_size or node_colour have the same lenght as the number of taxon names you are plotting. You can for example add another data layer to the taxmap object, or provide data from an independent df as the argument of node_size or node_colour.

TO explore this, lets first check some of the taxmap object structure, then create some random data and add it to the heat tree


```{r}

# let's review one of the more basic trees.
taxmap_obj %>%
  heat_tree(node_label = taxon_names,
            node_size = n_obs,
            node_color = n_obs,
            layout = "davidson-harel",
            initial_layout = "reingold-tilford")

#let's review what is actually used as input for node size and color
n_obs(taxmap_obj)

# ab, es, ff etc all refer to specific nodes int he tree taxonomic groups. the number referts to how many sequences belong to that taxonomy (all 1000 sequences, are part of Bacteria "ab", 574 are Proteobacteria "ac")
taxmap_obj$taxa

```

so if you have a vector from the same lenght of n_obs(taxmap_obj) with data from other analysis, you can visualize other outputs in a heat tree! lets prepare a df that will add new, random data



```{r}
#extract the names of the taxonomies in the heat tree, accoding the ab ac etc order
taxon_id_metacoder<-lapply(taxmap_obj$taxa, function (x)
                                                    x$get_name())%>%
                                                    map(1)

# now turn that list into a df
taxon_id_metacoder<-do.call(rbind.data.frame, map(taxon_id_metacoder,1))

# and change column name
colnames(taxon_id_metacoder)<-"taxa_id"

#make up some random data called new_data1
set.seed(1)
new_data1<-c(runif(n=100, min=1, max=10),
            runif(n=200, min=5, max=15),
            runif(n=100, min=10, max=20),
            runif(n=57, min=20, max=25))

#make up some random data called new_data2
set.seed(1)
new_data2<-c(runif(n=57, min=1000, max=2000),
             runif(n=200, min=600, max=1000),
             runif(n=200, min=200, max=500))


# add new (random example) data into the df
taxon_id_metacoder$new_analysis_output1<-new_data1
taxon_id_metacoder$new_analysis_output2<-new_data2

#this is the df we created using data external from metacoder
taxon_id_metacoder


# add the new data into the heat tree!
taxmap_obj %>%
  heat_tree(node_label = taxon_names,
            node_size = taxon_id_metacoder$new_analysis_output2,
            node_color = taxon_id_metacoder$new_analysis_output1,
            node_size_axis_label = "Size: new data 2",
            node_color_axis_label = "Color: new data 1",
            layout = "davidson-harel",
            initial_layout = "reingold-tilford")



```


Of course, there are countless ways you can integrate different pieces of data together - such as by matching the taxonomies ab, ac, ad etc; the names of the taxa like "f__Burkholderiales" etc. Note that you won't find sample code for this in the metacoder package documentation.












# 5.1 - adding results of a fisher tests to a heat tree

In the MeJA applications pilot were we tested different MeJA concentrations, we run different analysis that highlight taxa as "important": predictors for stress in random forest, keystone nodes in networks, and differentially abudnant ASVs in treatment-control comparisons. to select which of the taxonomies of these "important" taxa to focus on, we performed a fisher test to check if the proportions of a taxonomy are similar between the importnat ASVs and the ASVs that were not defined as important

```{r}
# load a list of ASV names. these ASVs were hihglted as differentially abundant due to stress OR important in random forest predictions for stress OR network keystone/connector/hub of the species in a more complete dataset. I call these the "important"ASVs
load( file="./data/imp_asv_list.Rdata")

imp_asv_list # as you see, this is just a list of taxa

# filter your list of phyloliseq objects to only contain the ASVs defined as "importat"
imp_ASV_ps_l<-mapply (function (list_1,list_2) #mapply will let you manipulate 2 or more lists at once
            prune_taxa(taxa = list_1, x = list_2), #here, x as the name of an argument of prune_taxa, and refers to a phyloseq object
          list_1 = imp_asv_list, # here you define what R object is list_1
          list_2 = ps_l, # here you define what R object is list_2
          SIMPLIFY = FALSE)

# this ps object only has "important" ASVs
imp_ASV_ps_l


```


## define the funciton that calculates fisher tests
```{r}


#define function that calculates proportion tests between 2 phyloseq objects
fisher_all_taxa_groups<-function(ps_important_taxa, ps_all_taxa){

#**********************************************#
############# fisher_all_taxa_groups ################
#**********************************************#

# this function takes 2 phyloseq objects as 2 arguments:
# ps_important_taxa =  a subset of imporntant taxa, such as ASVs tagged as important by differential abundance, random forest, and netowrk analysis
# ps_all_taxa = the full phyloseq objects from where you obtained the imporntat subset (and likely your input for differential abundance, random forest, and netowork analysis)

# Then it runs a fisher test, comparing the proportions of every taxonomic level accuting more than twice in both datasets
# it's just a test to compare proportions - is 6 out of 17 a similar proportion to 193 out of 2243?

  
  
# first, get the taxonomic groups of the taxa defined as important
  
  #this will get us a list of (taxa_level) that appears in the important subset more than once
  imp_phylum_l<-as.character(tax_table(ps_important_taxa)[,"Phylum"]) # gets a char vector  of "families" shown as relevant
  imp_phylum_l<-imp_phylum_l[imp_phylum_l != "p__uncultured"] # removes any taxonomy set as "uncultured"
  imp_phylum_l<-names(which(table(imp_phylum_l)>2))%>% # get names of taxa that occur ate least 1 time NOTE: CHANGED FROM >2
    na.omit()%>% #remove NA from classifications
    unique()%>%  #dereplicates repetitive values (avoids "f__Chitinophagaceae" "f__Chitinophagaceae" "f__Oxalobacteraceae")
    as.list(c()) # save the dereplicated values as a list
  
  # now, perfom the same as above for every taxa level... it's hard-coded, but it works well enough. Pedro tried automating this and gave up after a few hours
  imp_class_l<-as.character(tax_table(ps_important_taxa)[,"Class"]) 
  imp_class_l<-imp_class_l[imp_class_l != "c__uncultured"] 
  imp_class_l<-names(which(table(imp_class_l)>2))%>% 
    na.omit()%>% 
    unique()%>%  
    as.list(c()) 
  
  imp_order_l<-as.character(tax_table(ps_important_taxa)[,"Order"])
  imp_order_l<-imp_order_l[imp_order_l != "o__uncultured"]
  imp_order_l<-names(which(table(imp_order_l)>2))%>%
    na.omit()%>% 
    unique()%>%
    as.list(c()) 
  
  imp_fam_l<-as.character(tax_table(ps_important_taxa)[,"Family"])
  imp_fam_l<-imp_fam_l[imp_fam_l != "f__uncultured"]
  imp_fam_l<-names(which(table(imp_fam_l)>2))%>%
    na.omit()%>% 
    unique()%>% 
    as.list(c()) 
  
  imp_genus_l<-as.character(tax_table(ps_important_taxa)[,"Genus"])
  imp_genus_l<-imp_genus_l[imp_genus_l != "g__uncultured"]
  imp_genus_l<-names(which(table(imp_genus_l)>2))%>%
    na.omit()%>% 
    unique()%>% 
    as.list(c()) 
  
  
  
  
  
  
  
  
  
  # second, get the number of taxa occuring in each taxonomic group, within the imporntat taxa subset
  # note: using phyloseq::subset_taxa with a for loop will cause issues as your taxa is intepreted as "i"! to avoid this, use phyloseq::prune_taxa instead
  
  
  
  #make one empty lists to store results
  target_in_important_n<-list()
  
  # obtain the number of reads of the target taxa in the important subset
  for(i in imp_phylum_l) { #for every Phylum "i" with representatives defined as important....
    target_in_important_n[i]<-phyloseq::ntaxa(prune_taxa(taxa = tax_table(ps_important_taxa)[,"Phylum"] %in% i, # get only the taxa that belong to that particular phylum "i", then define the number of taxa in there, then save it in the empty list we just made to store the results
                                                         x = ps_important_taxa))
  }
  
  # now, perfom the same as above for every taxa level... it's hard-coded, but it works well enough. Pedro tried automating this and gave up after a few hours
  for(i in imp_class_l) {
    target_in_important_n[i]<-phyloseq::ntaxa(prune_taxa(taxa = tax_table(ps_important_taxa)[,"Class"] %in% i,
                                                         x = ps_important_taxa))
  }
  
  for(i in imp_order_l) {
    target_in_important_n[i]<-phyloseq::ntaxa(prune_taxa(taxa = tax_table(ps_important_taxa)[,"Order"] %in% i,
                                                         x = ps_important_taxa))
  }
  
  
  for(i in imp_fam_l) {
    target_in_important_n[i]<-phyloseq::ntaxa(prune_taxa(taxa = tax_table(ps_important_taxa)[,"Family"] %in% i,
                                                         x = ps_important_taxa))
  }
  
  for(i in imp_genus_l) {
    target_in_important_n[i]<-phyloseq::ntaxa(prune_taxa(taxa = tax_table(ps_important_taxa)[,"Genus"] %in% i,
                                                         x = ps_important_taxa))
  }
  
  
  
  
  
  
  
  
  
  # third, get the number of taxa occuring in each taxonomic group, within the full dataset 
  
  #make one empty lists to store results
  target_in_all_n<-list()
  
  # obtain the number of reads of the target taxa in the important subset
  for(i in imp_phylum_l) { #for every Phylum "i" with representatives defined as important....
    target_in_all_n[i]<-phyloseq::ntaxa(prune_taxa(taxa = tax_table(ps_all_taxa)[,"Phylum"] %in% i, # get only the taxa that belong to that particular phylum "i", then define the number of taxa in there, then save it in the empty list we just made to store the results
                                                   x = ps_all_taxa))
  }
  
  # now, perfom the same as above for every taxa level... it's hard-coded, but it works well enough. Pedro tried automating this and gave up after a few hours
  for(i in imp_class_l) {
    target_in_all_n[i]<-phyloseq::ntaxa(prune_taxa(taxa = tax_table(ps_all_taxa)[,"Class"] %in% i,
                                                   x = ps_all_taxa))
  }
  
  for(i in imp_order_l) {
    target_in_all_n[i]<-phyloseq::ntaxa(prune_taxa(taxa = tax_table(ps_all_taxa)[,"Order"] %in% i,
                                                   x = ps_all_taxa))
  }
  
  
  for(i in imp_fam_l) {
    target_in_all_n[i]<-phyloseq::ntaxa(prune_taxa(taxa = tax_table(ps_all_taxa)[,"Family"] %in% i,
                                                   x = ps_all_taxa))
  }
  
  for(i in imp_genus_l) {
    target_in_all_n[i]<-phyloseq::ntaxa(prune_taxa(taxa = tax_table(ps_all_taxa)[,"Genus"] %in% i,
                                                   x = ps_all_taxa))
  }
  
  
  
  
  
  
  
  
  
  # now, get the total number of taxa in the imporntat subset and in the full dataset
  
  # all important taxa
  all_taxa_in_important_n<-phyloseq::ntaxa(ps_important_taxa)
  
  #all taxa 
  all_taxa_in_all_n<-phyloseq::ntaxa(ps_all_taxa)
  
  
  
  
  
  
  
  
  
  # now perform fisher tests over lists; check online tutorials for fisher.test() if need
  
  # this contigency table: (summed marginal totals is equal to the total number of taxa the the full object)
  fisher_result<-mapply(function (target_in_important_n,target_in_all_n)
    fisher.test(matrix(c(target_in_important_n, 
                         all_taxa_in_important_n - target_in_important_n, 
                         target_in_all_n - target_in_important_n, 
                         all_taxa_in_all_n - all_taxa_in_important_n - target_in_all_n),
                       ncol=2),alternative = "greater" ), 
    target_in_all_n = target_in_all_n,
    target_in_important_n = target_in_important_n,
    SIMPLIFY = FALSE)
  
  return(fisher_result)
  
}

#define function that puts fisher tests in metacoder heat trees
fisher_to_heatTree<-function(fisher_output, ps_important_taxa){
#**********************************************#
############# fisher_to_heatTree ################
#**********************************************#
  
# this function takes 1 phyloseq object and the putput of the fisher_all_taxa_groups() function as 2 arguments:
# fisher_output =  The output of the function defined above, fisher_all_taxa_groups
# ps_important_taxa = a phtloseq object with the taxa classified as "important". it is the same input as you used in the function fisher_all_taxa_groups  

# this function will:
  # 1)  create a taxmap object from the phyloseq object
  # 2)  extract the p values from the fisher test and apply an fdr correction
  # 3)  extract the taxa names form the heat tree, and match it to the p values of the fisher test
  # 4)  extract the odds ratio from the fisher test and add it to the extracted p values adn taxonomies
  # 5)  creates a heat map of the important taxa, with colour for adjusted p values and node size for odds ratio

  
  
#######################################
######## make metacoder object ######## 
#######################################
imp_heat_ps<-ps_important_taxa

#remove unecessary taxonomic indo (dada2id, "S__" and" above_selected)
tax_table(imp_heat_ps)<-tax_table(imp_heat_ps)[,1:6]

# let's remove the "r__"ranks from the taxonomy, they can be useful but will pollute our plot
tax_table(imp_heat_ps)[, colnames(tax_table(imp_heat_ps))] <- gsub(pattern = "[a-z]__", # regular expression pattern to search for
                                                                   x = tax_table(imp_heat_ps)[, colnames(tax_table(imp_heat_ps))], # "df"
                                                                   replacement = "") # replacement for pattern

# transform from phyloseq to  taxmap object
imp_heat<-parse_phyloseq(imp_heat_ps)



#######################################
######## aplly fdr to fisher ######## 
#######################################

#apply FDR correction to the p values

  #single df with all p values
  pvector<-do.call(rbind.data.frame, map(fisher_output,1))
  
  # adjust the p value with fdr, then save as a list
  adjusted_p<-p.adjust(p = pvector[[1]],
                          method = "fdr")%>%
                      as.list()
  # adjust names
  names(adjusted_p)<-names(fisher_output)

  

#this is the name that mustch match our fisher p list
taxon_id_metacoder<-lapply(imp_heat$taxa, function (x)
                                                    x$get_name())%>%
                                                    map(1)


# now turn that list into a df
taxon_id_metacoder<-do.call(rbind.data.frame, map(taxon_id_metacoder,1))

# and change column name
colnames(taxon_id_metacoder)<-"taxa_id"

# truns the p values into a dataframe
adjusted_p_input<-as.data.frame(t(as.data.frame(adjusted_p)))%>%
  rownames_to_column()

#change column names
colnames(adjusted_p_input)<-c("taxa_id", "fdr_p")
  
# now join both df
fdr_for_heatTree<-left_join(taxon_id_metacoder,
                            adjusted_p_input,
                            by = "taxa_id")



#######################################################################
################### add fold changes! ########################################
#######################################################################


# get odds ratio for each taxa
odd_list<- map(fisher_output,3)%>%
  map(1)

# truns the p values into a dataframe
odd_list<-as.data.frame(t(as.data.frame(odd_list)))%>%
  rownames_to_column()

#change column names
colnames(odd_list)<-c("taxa_id", "odds_ratio")

# now join both df
fisher_for_heatTree<-left_join(fdr_for_heatTree,
                            odd_list,
                            by = "taxa_id")




#NAs will crash metadore. let's change them with 0.9999 for now
fisher_for_heatTree[is.na(fisher_for_heatTree)]<-"1"

#change structure to numeric
fisher_for_heatTree$fdr_p<-as.numeric(fisher_for_heatTree$fdr_p)
fisher_for_heatTree$odds_ratio<-as.numeric(fisher_for_heatTree$odds_ratio)


#now let's dim p values above 0.1, or else we can get counfounded
#fisher_for_heatTree$fdr_p[fisher_for_heatTree$fdr_p>0.1]<-1







#######################################################################
############### now plot the heat tree ############### 
#######################################################################



set.seed(1)
      output<- heat_tree(imp_heat,
                 node_size = fisher_for_heatTree$odds_ratio, # n_obs is a function that calculates, in this case, the number of OTUs per taxon
                 node_color = fisher_for_heatTree$fdr_p,
                 node_label = taxon_names,
                 node_size_axis_label = "Size: oods_ratio",
                 node_color_interval = c(0, 0.15),
                 edge_color_interval = c(0, 0.15),
                 node_color_range = c("darkgreen", "seagreen", "yellowgreen", "grey"),
                 edge_color_range = c("darkgreen", "seagreen", "yellowgreen", "grey"),
                 node_color_axis_label = "Color: FDR-adjusted p",
                 layout = "davidson-harel", # The primary layout algorithm
                 initial_layout = "reingold-tilford") # The layout algorithm that initializes node locations

      return(output)
}





```

## calculate prortions of the fisher test
is a specific taxonomy overly frequent in the "important" dataset when compared to the taxonomies of the ASV that were NOT defined as important?

```{r}


# how many rhizobiales do we have in full set of 963 ASVs of A. thaliana?
ntaxa(subset_taxa(ps_l$At, Order == "Rhizobiales"))

# how many rhizobiales do we have in the group of 114 "important" ASVs for A. thaliana?
ntaxa(subset_taxa(imp_ASV_ps_l$At, Order == "Rhizobiales"))

# how many rhizobiales do we have in the set of 849 A. thaliana ASVs that were not tagged as important ?
unimp_ASV_ps_at<-prune_taxa(!(taxa_names(ps_l$At) %in% imp_asv_list$At),
                            ps_l$At)%>% # a ps object with the "unimporntat" ASVs
ntaxa(subset_taxa(unimp_ASV_ps_at , Order == "Rhizobiales"))

#is 18 in 114 (~15%) similar to 63 in 849 (~7%)? if these proportions are statistically different, rhizobiales may be overrepresented in the important ASV


# run a fisher test comparin these proportions at all taxonomic levels
fisher_output_at<-fisher_all_taxa_groups(ps_important_taxa = imp_ASV_ps_l$At,
                                         ps_all_taxa = ps_l$At)

#check raw ouput of fisher tests for rhizobiales
fisher_output_at
fisher_output_at$Rhizobiales

# extract p values and odds ration from the fisher tests and put it into the heat tree
fisher_to_heatTree(fisher_output = fisher_output_at, 
                   ps_important_taxa = imp_ASV_ps_l$At)

```







now, run these custom functions over lists of phyloseq objects separated by species

```{r}

# run the custom function voer 2 lists of philoseq objects, one with imporntat taxa and other with the full taxa (for every partition)
fisher_result_l<-mapply(function (list_1,list_2)
                   fisher_all_taxa_groups(ps_important_taxa = list_1, 
                                          ps_all_taxa = list_2),
                   list_1 = imp_ASV_ps_l,
                   list_2 = ps_l,
                   SIMPLIFY = FALSE)


#run the custom function on a list of 3 species
fisher_summaries_3l<-mapply(function(list_1,list_2)
    fisher_to_heatTree(fisher_output = list_1,
                       ps_important_taxa = list_2),
    list_1 = fisher_result_l,
    list_2 = imp_ASV_ps_l,
    SIMPLIFY = FALSE)





```

Are you curious about all the data wrangling of these 2 custom functions? here you can execute a hard-coded version of the function, where you can visualize each object step by step.



```{r}

#hard-code input arguments of fisher_all_taxa_groups()
ps_important_taxa<-imp_ASV_ps_l$At
ps_all_taxa<-ps_l$At

 
# first, get the taxonomic groups of the taxa defined as important
  
  #this will get us a list of (taxa_level) that appears in the important subset more than once
  imp_phylum_l<-as.character(tax_table(ps_important_taxa)[,"Phylum"]) # gets a char vector  of "families" shown as relevant
  imp_phylum_l<-imp_phylum_l[imp_phylum_l != "p__uncultured"] # removes any taxonomy set as "uncultured"
  imp_phylum_l<-names(which(table(imp_phylum_l)>2))%>% # get names of taxa that occur ate least 1 time NOTE: CHANGED FROM >2
    na.omit()%>% #remove NA from classifications
    unique()%>%  #dereplicates repetitive values (avoids "f__Chitinophagaceae" "f__Chitinophagaceae" "f__Oxalobacteraceae")
    as.list(c()) # save the dereplicated values as a list
  
  # now, perfom the same as above for every taxa level... it's hard-coded, but it works well enough. Pedro tried automating this and gave up after a few hours
  imp_class_l<-as.character(tax_table(ps_important_taxa)[,"Class"]) 
  imp_class_l<-imp_class_l[imp_class_l != "c__uncultured"] 
  imp_class_l<-names(which(table(imp_class_l)>2))%>% 
    na.omit()%>% 
    unique()%>%  
    as.list(c()) 
  
  imp_order_l<-as.character(tax_table(ps_important_taxa)[,"Order"])
  imp_order_l<-imp_order_l[imp_order_l != "o__uncultured"]
  imp_order_l<-names(which(table(imp_order_l)>2))%>%
    na.omit()%>% 
    unique()%>%
    as.list(c()) 
  
  imp_fam_l<-as.character(tax_table(ps_important_taxa)[,"Family"])
  imp_fam_l<-imp_fam_l[imp_fam_l != "f__uncultured"]
  imp_fam_l<-names(which(table(imp_fam_l)>2))%>%
    na.omit()%>% 
    unique()%>% 
    as.list(c()) 
  
  imp_genus_l<-as.character(tax_table(ps_important_taxa)[,"Genus"])
  imp_genus_l<-imp_genus_l[imp_genus_l != "g__uncultured"]
  imp_genus_l<-names(which(table(imp_genus_l)>2))%>%
    na.omit()%>% 
    unique()%>% 
    as.list(c()) 
  

  
  
  
  
  # second, get the number of taxa occuring in each taxonomic group, within the imporntat taxa subset
  # note: using phyloseq::subset_taxa with a for loop will cause issues as your taxa is intepreted as "i"! to avoid this, use phyloseq::prune_taxa instead
  
  
  
  #make one empty lists to store results
  target_in_important_n<-list()
  
  # obtain the number of reads of the target taxa in the important subset
  for(i in imp_phylum_l) { #for every Phylum "i" with representatives defined as important....
    target_in_important_n[i]<-phyloseq::ntaxa(prune_taxa(taxa = tax_table(ps_important_taxa)[,"Phylum"] %in% i, # get only the taxa that belong to that particular phylum "i", then define the number of taxa in there, then save it in the empty list we just made to store the results
                                                         x = ps_important_taxa))
  }
  
  # now, perfom the same as above for every taxa level... it's hard-coded, but it works well enough. Pedro tried automating this and gave up after a few hours
  for(i in imp_class_l) {
    target_in_important_n[i]<-phyloseq::ntaxa(prune_taxa(taxa = tax_table(ps_important_taxa)[,"Class"] %in% i,
                                                         x = ps_important_taxa))
  }
  
  for(i in imp_order_l) {
    target_in_important_n[i]<-phyloseq::ntaxa(prune_taxa(taxa = tax_table(ps_important_taxa)[,"Order"] %in% i,
                                                         x = ps_important_taxa))
  }
  
  
  for(i in imp_fam_l) {
    target_in_important_n[i]<-phyloseq::ntaxa(prune_taxa(taxa = tax_table(ps_important_taxa)[,"Family"] %in% i,
                                                         x = ps_important_taxa))
  }
  
  for(i in imp_genus_l) {
    target_in_important_n[i]<-phyloseq::ntaxa(prune_taxa(taxa = tax_table(ps_important_taxa)[,"Genus"] %in% i,
                                                         x = ps_important_taxa))
  }
  
  
  
  
  
  
  
  
  
  # third, get the number of taxa occuring in each taxonomic group, within the full dataset 
  
  #make one empty lists to store results
  target_in_all_n<-list()
  
  # obtain the number of reads of the target taxa in the important subset
  for(i in imp_phylum_l) { #for every Phylum "i" with representatives defined as important....
    target_in_all_n[i]<-phyloseq::ntaxa(prune_taxa(taxa = tax_table(ps_all_taxa)[,"Phylum"] %in% i, # get only the taxa that belong to that particular phylum "i", then define the number of taxa in there, then save it in the empty list we just made to store the results
                                                   x = ps_all_taxa))
  }
  
  # now, perfom the same as above for every taxa level... it's hard-coded, but it works well enough. Pedro tried automating this and gave up after a few hours
  for(i in imp_class_l) {
    target_in_all_n[i]<-phyloseq::ntaxa(prune_taxa(taxa = tax_table(ps_all_taxa)[,"Class"] %in% i,
                                                   x = ps_all_taxa))
  }
  
  for(i in imp_order_l) {
    target_in_all_n[i]<-phyloseq::ntaxa(prune_taxa(taxa = tax_table(ps_all_taxa)[,"Order"] %in% i,
                                                   x = ps_all_taxa))
  }
  
  
  for(i in imp_fam_l) {
    target_in_all_n[i]<-phyloseq::ntaxa(prune_taxa(taxa = tax_table(ps_all_taxa)[,"Family"] %in% i,
                                                   x = ps_all_taxa))
  }
  
  for(i in imp_genus_l) {
    target_in_all_n[i]<-phyloseq::ntaxa(prune_taxa(taxa = tax_table(ps_all_taxa)[,"Genus"] %in% i,
                                                   x = ps_all_taxa))
  }
  
  
  
  
  
  
  
  
  
  # now, get the total number of taxa in the imporntat subset and in the full dataset
  
  # all important taxa
  all_taxa_in_important_n<-phyloseq::ntaxa(ps_important_taxa)
  
  #all taxa 
  all_taxa_in_all_n<-phyloseq::ntaxa(ps_all_taxa)
  
  
  
  
  
  
  
  
  
  # now perform fisher tests over lists; check online tutorials for fisher.test() if need
  
  # this contigency table: (summed marginal totals is equal to the total number of taxa the the full object)
  fisher_result<-mapply(function (target_in_important_n,target_in_all_n)
    fisher.test(matrix(c(target_in_important_n, 
                         all_taxa_in_important_n - target_in_important_n, 
                         target_in_all_n - target_in_important_n, 
                         all_taxa_in_all_n - all_taxa_in_important_n - target_in_all_n),
                       ncol=2),alternative = "greater" ), 
    target_in_all_n = target_in_all_n,
    target_in_important_n = target_in_important_n,
    SIMPLIFY = FALSE)

  
  
#output of the function
  fisher_result

```


```{r}



#hard-code input arguments of fisher_all_taxa_groups()
ps_important_taxa<-imp_ASV_ps_l$At
fisher_output<-fisher_result



#######################################
######## make metacoder object ######## 
#######################################
imp_heat_ps<-ps_important_taxa

#remove unecessary taxonomic indo (dada2id, "S__" and" above_selected)
tax_table(imp_heat_ps)<-tax_table(imp_heat_ps)[,1:6]

# let's remove the "r__"ranks from the taxonomy, they can be useful but will pollute our plot
tax_table(imp_heat_ps)[, colnames(tax_table(imp_heat_ps))] <- gsub(pattern = "[a-z]__", # regular expression pattern to search for
                                                                   x = tax_table(imp_heat_ps)[, colnames(tax_table(imp_heat_ps))], # "df"
                                                                   replacement = "") # replacement for pattern

# transform from phyloseq to  taxmap object
imp_heat<-parse_phyloseq(imp_heat_ps)



#######################################
######## aplly fdr to fisher ######## 
#######################################

#apply FDR correction to the p values

  #single df with all p values
  pvector<-do.call(rbind.data.frame, map(fisher_output,1))
  
  # adjust the p value with fdr, then save as a list
  adjusted_p<-p.adjust(p = pvector[[1]],
                          method = "fdr")%>%
                      as.list()
  # adjust names
  names(adjusted_p)<-names(fisher_output)

  

#this is the name that mustch match our fisher p list
taxon_id_metacoder<-lapply(imp_heat$taxa, function (x)
                                                    x$get_name())%>%
                                                    map(1)


# now turn that list into a df
taxon_id_metacoder<-do.call(rbind.data.frame, map(taxon_id_metacoder,1))

# and change column name
colnames(taxon_id_metacoder)<-"taxa_id"

# truns the p values into a dataframe
adjusted_p_input<-as.data.frame(t(as.data.frame(adjusted_p)))%>%
  rownames_to_column()

#change column names
colnames(adjusted_p_input)<-c("taxa_id", "fdr_p")
  
# now join both df
fdr_for_heatTree<-left_join(taxon_id_metacoder,
                            adjusted_p_input,
                            by = "taxa_id")



#######################################################################
################### add fold changes! ########################################
#######################################################################


# get odds ratio for each taxa
odd_list<- map(fisher_output,3)%>%
  map(1)

# truns the p values into a dataframe
odd_list<-as.data.frame(t(as.data.frame(odd_list)))%>%
  rownames_to_column()

#change column names
colnames(odd_list)<-c("taxa_id", "odds_ratio")

# now join both df
fisher_for_heatTree<-left_join(fdr_for_heatTree,
                            odd_list,
                            by = "taxa_id")




#NAs will crash metadore. let's change them with 0.9999 for now
fisher_for_heatTree[is.na(fisher_for_heatTree)]<-"1"

#change structure to numeric
fisher_for_heatTree$fdr_p<-as.numeric(fisher_for_heatTree$fdr_p)
fisher_for_heatTree$odds_ratio<-as.numeric(fisher_for_heatTree$odds_ratio)


#now let's dim p values above 0.1, or else we can get counfounded
#fisher_for_heatTree$fdr_p[fisher_for_heatTree$fdr_p>0.1]<-1







#######################################################################
############### now plot the heat tree ############### 
#######################################################################



set.seed(1)
      output<- heat_tree(imp_heat,
                 node_size = fisher_for_heatTree$odds_ratio, # n_obs is a function that calculates, in this case, the number of OTUs per taxon
                 node_color = fisher_for_heatTree$fdr_p,
                 node_label = taxon_names,
                 node_size_axis_label = "Size: oods_ratio",
                 node_color_interval = c(0, 0.15),
                 edge_color_interval = c(0, 0.15),
                 node_color_range = c("darkgreen", "seagreen", "yellowgreen", "grey"),
                 edge_color_range = c("darkgreen", "seagreen", "yellowgreen", "grey"),
                 node_color_axis_label = "Color: FDR-adjusted p",
                 layout = "davidson-harel", # The primary layout algorithm
                 initial_layout = "reingold-tilford") # The layout algorithm that initializes node locations

```

